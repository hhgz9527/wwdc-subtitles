1
00:00:17,551 --> 00:00:21,688 line:10%
<c.magenta>（Foundation新特性）</c>


2
00:00:21,755 --> 00:00:22,589 line:10%
<c.magenta>大家好</c>


3
00:00:27,561 --> 00:00:28,428 line:90%,end
<c.magenta>欢迎到来</c>


4
00:00:28,562 --> 00:00:31,632 line:90%,end
<c.magenta>我的名字叫托尼·帕克</c>
<c.magenta>我是Apple Foundation团队的经理</c>


5
00:00:31,698 --> 00:00:34,368 line:90%,end
<c.magenta>我今天和我的同事迈克尔·乐修</c>
<c.magenta>还有毅太·费伯一起</c>


6
00:00:34,434 --> 00:00:36,370 line:90%,end
<c.magenta>告诉你们有关Foundation的新特性</c>


7
00:00:37,404 --> 00:00:38,705 line:90%,end
<c.magenta>我们今天有三个主题</c>


8
00:00:38,906 --> 00:00:42,276 line:90%,end
<c.magenta>首先我们要快速浏览一遍</c>
<c.magenta>一些新的API重点</c>


9
00:00:42,342 --> 00:00:44,144 line:90%,end
<c.magenta>来自于今年Foundation</c>
<c.magenta>的发布</c>


10
00:00:44,978 --> 00:00:48,081 line:90%,end
<c.magenta>在那之后 我们要进入</c>
<c.magenta>两个主要主题的第一个</c>


11
00:00:48,248 --> 00:00:51,185 line:90%,end
<c.magenta>键路径和键值观察API</c>


12
00:00:52,386 --> 00:00:56,056 line:90%,end
<c.magenta>在那之后 我们将讨论</c>
<c.magenta>新的编码和解码API</c>


13
00:00:56,924 --> 00:00:59,660 line:90%,end
<c.magenta>让我们从那些新的API重点开始吧</c>


14
00:01:02,563 --> 00:01:05,299 line:90%,end
<c.magenta>首先今年我们强化了</c>
<c.magenta>FileProvider API</c>


15
00:01:05,364 --> 00:01:07,467 line:90%,end
<c.magenta>去年我们作为iOS 10</c>
<c.magenta>的一部分所引入的</c>


16
00:01:08,302 --> 00:01:10,370 line:90%,end
<c.magenta>这增强了你交互的能力</c>


17
00:01:10,437 --> 00:01:14,074 line:90%,end
<c.magenta>在FileProvider扩展</c>
<c.magenta>与其他应用之间</c>


18
00:01:15,676 --> 00:01:18,545 line:90%,end
<c.magenta>我们已经改进了可用存储空间API</c>


19
00:01:18,712 --> 00:01:22,416 line:90%,end
<c.magenta>这是一个在MSURL上的新API</c>
<c.magenta>它让你不仅能了解</c>


20
00:01:22,482 --> 00:01:25,452 line:90%,end
<c.magenta>你用户的设备上有多少剩余空间可用</c>


21
00:01:25,519 --> 00:01:27,287 line:90%,end
<c.magenta>而且可以了解</c>
<c.magenta>有多少空间可以被利用</c>


22
00:01:27,354 --> 00:01:31,592 line:90%,end
<c.magenta>如果我们清除像是缓存或者旧数据</c>
<c.magenta>这些不必需的内容</c>


23
00:01:33,594 --> 00:01:37,464 line:90%,end
<c.magenta>我们在NS range和Swift range中</c>
<c.magenta>加入了新的API来帮助转换</c>


24
00:01:37,531 --> 00:01:40,367 line:90%,end
<c.magenta>NS range中NSString的使用</c>


25
00:01:40,434 --> 00:01:42,636 line:90%,end
<c.magenta>以及Swift range中</c>
<c.magenta>Swift string的使用</c>


26
00:01:43,036 --> 00:01:47,374 line:90%,end
<c.magenta>这对于像是AttributedString和</c>
<c.magenta>RegularExpression的类特别有用</c>


27
00:01:49,243 --> 00:01:53,680 line:90%,end
<c.magenta>在NSXPCConnection中 我们加入了</c>
<c.magenta>对于NSProgress更好的支持</c>


28
00:01:54,081 --> 00:01:56,250 line:90%,end
<c.magenta>实际上第一个东西真的很有趣</c>


29
00:01:56,316 --> 00:02:01,121 line:90%,end
<c.magenta>因为在扩展</c>
<c.magenta>和应用之间新增强的交流能力</c>


30
00:02:01,188 --> 00:02:05,392 line:90%,end
<c.magenta>实际上是NSXPCConnection</c>
<c.magenta>这是今年首次在iOS上可用</c>


31
00:02:06,059 --> 00:02:08,929 line:90%,end
<c.magenta>NSURLSession也获得了对于</c>
<c.magenta>NSProgress的支持</c>


32
00:02:09,062 --> 00:02:10,931 line:90%,end
<c.magenta>因为我们希望你们可以使用</c>


33
00:02:10,997 --> 00:02:15,736 line:90%,end
<c.magenta>所有这些进程功能来使得从下载</c>


34
00:02:15,802 --> 00:02:19,339 line:90%,end
<c.magenta>到扩展 到应用</c>
<c.magenta>到显示给你的用户一气呵成</c>


35
00:02:21,175 --> 00:02:23,110 line:90%,end
<c.magenta>最后我们还引入了热通知</c>


36
00:02:23,177 --> 00:02:25,012 line:90%,end
<c.magenta>今年从Mac到iOS上</c>


37
00:02:26,246 --> 00:02:28,582 line:90%,end
<c.magenta>对于这些主题的更多内容</c>
<c.magenta>请参见Cocoa新特性</c>


38
00:02:28,649 --> 00:02:30,150 line:90%,end
<c.magenta>它是在今天早上</c>
<c.magenta>如果你错过了的话</c>


39
00:02:30,217 --> 00:02:33,554 line:90%,end
<c.magenta>在那场演讲上 我们有相当多</c>
<c.magenta>关于Foundation的内容</c>


40
00:02:35,656 --> 00:02:38,625 line:90%,end
<c.magenta>性能也是我们今年在Foundation上的</c>


41
00:02:38,692 --> 00:02:40,027 line:90%,end
<c.magenta>一个关键考虑因素</c>


42
00:02:40,260 --> 00:02:43,564 line:90%,end
<c.magenta>从一个有关NSArray的</c>
<c.magenta>新copy-on-write行为开始</c>


43
00:02:43,630 --> 00:02:46,767 line:90%,end
<c.magenta>以及它的词典 NSSet</c>
<c.magenta>还有它们易变的朋友</c>


44
00:02:47,568 --> 00:02:50,771 line:90%,end
<c.magenta>对于它一个很大的刺激因素是</c>
<c.magenta>将桥接引入到Swift</c>


45
00:02:51,104 --> 00:02:55,209 line:90%,end
<c.magenta>因此当Objective-C API</c>
<c.magenta>返回NSArray时</c>


46
00:02:55,275 --> 00:02:57,911 line:90%,end
<c.magenta>也许是在一个框架里</c>
<c.magenta>并且你在Swift中使用它</c>


47
00:02:57,978 --> 00:03:01,048 line:90%,end
<c.magenta>你接收到了Swift的值类型：</c>
<c.magenta>阵列、词典和套</c>


48
00:03:01,448 --> 00:03:03,317 line:90%,end
<c.magenta>为了保留这些值语义</c>


49
00:03:03,383 --> 00:03:06,486 line:90%,end
<c.magenta>那些结构在引入类型上调用复制</c>


50
00:03:06,553 --> 00:03:07,821 line:90%,end
<c.magenta>当它们在做桥接的时候</c>


51
00:03:08,222 --> 00:03:10,858 line:90%,end
<c.magenta>如果结果恰好是共有子类的一个</c>


52
00:03:10,924 --> 00:03:12,793 line:90%,end
<c.magenta>那么复制会开销很大</c>


53
00:03:13,227 --> 00:03:17,030 line:90%,end
<c.magenta>现在我们可以延迟复制的花销</c>
<c.magenta>直到其真的改变了</c>


54
00:03:17,097 --> 00:03:18,365 line:90%,end
<c.magenta>如果真发生的话</c>


55
00:03:18,432 --> 00:03:20,868 line:90%,end
<c.magenta>这会导致相当大的改进</c>


56
00:03:20,934 --> 00:03:22,269 line:90%,end
<c.magenta>对于桥接时的性能来说</c>


57
00:03:23,904 --> 00:03:27,174 line:90%,end
<c.magenta>结构体数据作为</c>
<c.magenta>Swift Foundation的一部分</c>


58
00:03:27,241 --> 00:03:29,576 line:90%,end
<c.magenta>也获得很多性能增强</c>


59
00:03:29,743 --> 00:03:33,046 line:90%,end
<c.magenta>特别酷的是 我们可以直列</c>


60
00:03:33,113 --> 00:03:36,450 line:90%,end
<c.magenta>数据行为的关键部分到你的应用里</c>
<c.magenta>当你编译的时候</c>


61
00:03:36,850 --> 00:03:40,754 line:90%,end
<c.magenta>这包括像是在数据里挨个字节编序号</c>


62
00:03:40,821 --> 00:03:44,892 line:90%,end
<c.magenta>这同样获得相当大的性能改进</c>


63
00:03:46,093 --> 00:03:48,095 line:90%,end
<c.magenta>NSCalendar获得了</c>
<c.magenta>更好的性能表现</c>


64
00:03:48,161 --> 00:03:50,797 line:90%,end
<c.magenta>在CPU时间以及</c>
<c.magenta>更低的峰值内存方面</c>


65
00:03:50,864 --> 00:03:52,900 line:90%,end
<c.magenta>除此之外 我们还改进了结果</c>


66
00:03:52,966 --> 00:03:55,202 line:90%,end
<c.magenta>它所给你的 特别是在边界情况上</c>


67
00:03:56,670 --> 00:04:00,374 line:90%,end
<c.magenta>最后我们改进了桥接NSNumber</c>
<c.magenta>发往和来自于Swift的性能表现</c>


68
00:04:00,440 --> 00:04:03,944 line:90%,end
<c.magenta>我们同样也改进了</c>
<c.magenta>其在边界情况的行为</c>


69
00:04:04,011 --> 00:04:07,347 line:90%,end
<c.magenta>来提供更好的安全性</c>
<c.magenta>当你在转换</c>


70
00:04:07,414 --> 00:04:10,517 line:90%,end
<c.magenta>从NSNumber到Swift数据类型时</c>
<c.magenta>像是整型、布尔这些</c>


71
00:04:11,351 --> 00:04:14,755 line:90%,end
<c.magenta>这种更快的桥接对于像是属性表解析</c>
<c.magenta>这类有着很大的影响</c>


72
00:04:15,522 --> 00:04:16,957 line:90%,end
<c.magenta>有关这些主题的更多内容</c>


73
00:04:17,024 --> 00:04:18,858 line:90%,end
<c.magenta>请观看“与框架高效互动”</c>


74
00:04:18,926 --> 00:04:20,427 line:90%,end
<c.magenta>那是在周五下午1：50</c>


75
00:04:21,228 --> 00:04:23,430 line:90%,end
<c.magenta>现在我将舞台交给我的同事迈克尔</c>


76
00:04:23,497 --> 00:04:25,699 line:90%,end
<c.magenta>来谈谈键路径和键值观察</c>


77
00:04:34,942 --> 00:04:35,876 line:90%,end
<c.magenta>谢谢 托尼</c>


78
00:04:36,376 --> 00:04:40,447 line:90%,end
<c.magenta>嗨 我是来自Foundation团队的迈克尔</c>
<c.magenta>我很兴奋可以共享一些改进</c>


79
00:04:40,514 --> 00:04:43,584 line:90%,end
<c.magenta>有关我们今年对于键路径</c>
<c.magenta>和键值观察所做的</c>


80
00:04:43,650 --> 00:04:47,487 line:90%,end
<c.magenta>我想要从Foundation团队中</c>
<c.magenta>有强烈感觉的一些东西谈起</c>


81
00:04:47,855 --> 00:04:48,956 line:90%,end
<c.magenta>就是键路径</c>


82
00:04:49,022 --> 00:04:51,291 line:90%,end
<c.magenta>在Cocoa开发中非常重要</c>


83
00:04:51,892 --> 00:04:54,628 line:90%,end
<c.magenta>因为它让我们推论出类型的结构</c>


84
00:04:54,695 --> 00:04:56,830 line:90%,end
<c.magenta>除了任何特定情况</c>


85
00:04:56,897 --> 00:04:59,266 line:90%,end
<c.magenta>以一种比起终结更具限制性的方式</c>


86
00:05:00,234 --> 00:05:02,836 line:90%,end
<c.magenta>我们觉得这非常重要</c>
<c.magenta>因为它们保证了</c>


87
00:05:02,903 --> 00:05:04,805 line:90%,end
<c.magenta>对于语言本身的特别处理</c>


88
00:05:08,108 --> 00:05:12,713 line:90%,end
<c.magenta>我们从去年将字符串键路径添加</c>
<c.magenta>到Swift 3就开始着手做这个了</c>


89
00:05:13,547 --> 00:05:18,051 line:90%,end
<c.magenta>其使得Swift获得了能力</c>
<c.magenta>在编译时间</c>


90
00:05:18,118 --> 00:05:20,521 line:90%,end
<c.magenta>保证了一个Objective-C</c>
<c.magenta>键路径的正确性</c>


91
00:05:21,154 --> 00:05:22,155 line:90%,end
<c.magenta>也就是我现在要说的</c>


92
00:05:22,556 --> 00:05:24,024 line:90%,end
<c.magenta>假设我们有个Kid类</c>


93
00:05:24,091 --> 00:05:25,926 line:90%,end
<c.magenta>它有一些键值可观察的属性</c>


94
00:05:25,993 --> 00:05:27,761 line:90%,end
<c.magenta>像是他们的昵称 年龄</c>


95
00:05:27,828 --> 00:05:30,130 line:90%,end
<c.magenta>当然了 还有他们现在最好的朋友</c>


96
00:05:30,197 --> 00:05:32,065 line:90%,end
<c.magenta>我们可以继续构造一个实例</c>


97
00:05:32,132 --> 00:05:34,168 line:90%,end
<c.magenta>在这里例子中 一个叫本基的小男孩</c>


98
00:05:35,235 --> 00:05:38,272 line:90%,end
<c.magenta>然后形成了一个到孩子昵称属性</c>
<c.magenta>的字符串键径</c>


99
00:05:38,505 --> 00:05:40,707 line:90%,end
<c.magenta>接着 Swift编译器会确认</c>


100
00:05:40,774 --> 00:05:42,910 line:90%,end
<c.magenta>这对我们来说是合理的</c>


101
00:05:43,810 --> 00:05:46,813 line:10%
<c.magenta>接着我们可以用键值或者键值编码</c>


102
00:05:46,880 --> 00:05:49,783 line:10%
<c.magenta>来读取或者将该变量写回到实例中</c>


103
00:05:51,518 --> 00:05:53,220 line:90%,end
<c.magenta>现在 我们通过字符串键径</c>


104
00:05:53,287 --> 00:05:56,456 line:90%,end
<c.magenta>而获得的当前编译时间检查</c>
<c.magenta>表达式非常棒</c>


105
00:05:56,823 --> 00:05:59,193 line:90%,end
<c.magenta>最终它还是会编译到一个字符串</c>


106
00:06:00,093 --> 00:06:03,630 line:90%,end
<c.magenta>为了让该字符串有用</c>
<c.magenta>我们需要使用Objective-C运行时间</c>


107
00:06:03,697 --> 00:06:07,201 line:90%,end
<c.magenta>之前我看的时候</c>
<c.magenta>对于Swift值类型还是不可用的</c>


108
00:06:07,267 --> 00:06:09,703 line:90%,end
<c.magenta>而且大概短时间内不可能变得可用</c>


109
00:06:10,771 --> 00:06:15,142 line:90%,end
<c.magenta>最后 字符串键径不携带类型信息</c>


110
00:06:15,209 --> 00:06:16,376 line:90%,end
<c.magenta>它就是一个字符串</c>


111
00:06:17,678 --> 00:06:20,414 line:90%,end
<c.magenta>因此所有使用字符串键径</c>
<c.magenta>的通用API</c>


112
00:06:20,480 --> 00:06:23,217 line:10%
<c.magenta>无论如何都需要被定义</c>


113
00:06:25,052 --> 00:06:27,821 line:10%
<c.magenta>但这是Swift</c>
<c.magenta>我们当然可以做得更好</c>


114
00:06:28,355 --> 00:06:30,257 line:10%
<c.magenta>因为我们考虑 什么可以</c>


115
00:06:30,324 --> 00:06:32,593 line:10%
<c.magenta>键径 它们在Swift中</c>
<c.magenta>应该是什么样呢？</c>


116
00:06:33,427 --> 00:06:35,195 line:90%,end
<c.magenta>首先我们想要能描述属性</c>


117
00:06:35,262 --> 00:06:36,597 line:90%,end
<c.magenta>这很必要</c>


118
00:06:36,663 --> 00:06:38,398 line:90%,end
<c.magenta>它们应该是静态类型安全的</c>


119
00:06:39,766 --> 00:06:40,934 line:90%,end
<c.magenta>它们同样也要很快</c>


120
00:06:41,301 --> 00:06:44,705 line:90%,end
<c.magenta>并且它们应该可以处理</c>
<c.magenta>我们在Swift中所能遇到的所有值</c>


121
00:06:46,340 --> 00:06:49,376 line:90%,end
<c.magenta>它们应该可以在</c>
<c.magenta>Swift所支持的所有平台工作</c>


122
00:06:49,977 --> 00:06:51,211 line:90%,end
<c.magenta>因此我们考虑了很长时间</c>


123
00:06:51,278 --> 00:06:54,014 line:90%,end
<c.magenta>如何使得所有这些键径梦想成真</c>


124
00:06:54,348 --> 00:06:56,283 line:90%,end
<c.magenta>最终跟世界分享我们的点子</c>


125
00:06:56,350 --> 00:06:58,418 line:90%,end
<c.magenta>通过开源Swift进化过程</c>


126
00:06:58,485 --> 00:07:02,322 line:90%,end
<c.magenta>还有一份名为</c>
<c.magenta>SE-0161智能键径的文档</c>


127
00:07:02,856 --> 00:07:05,692 line:90%,end
<c.magenta>这就是Swift 4中</c>
<c.magenta>新键径字面量看起来是什么样的</c>


128
00:07:07,227 --> 00:07:09,029 line:90%,end
<c.magenta>从反斜线符号开始</c>


129
00:07:10,597 --> 00:07:12,666 line:90%,end
<c.magenta>跟着基类型的名字</c>


130
00:07:13,166 --> 00:07:16,603 line:90%,end
<c.magenta>一个点表明我们是在该基类型里</c>
<c.magenta>要做些什么</c>


131
00:07:16,670 --> 00:07:18,172 line:90%,end
<c.magenta>然后就是属性的名字</c>


132
00:07:19,540 --> 00:07:21,508 line:90%,end
<c.magenta>这里的反斜线符号很重要</c>


133
00:07:21,575 --> 00:07:24,611 line:90%,end
<c.magenta>因为它帮助我们消除了</c>
<c.magenta>执行属性的歧义</c>


134
00:07:24,678 --> 00:07:27,247 line:90%,end
<c.magenta>还有属性的提及或者引用</c>


135
00:07:28,148 --> 00:07:33,487 line:90%,end
<c.magenta>当然了这是Swift</c>
<c.magenta>因此当我们推断基类型时</c>


136
00:07:33,554 --> 00:07:35,389 line:90%,end
<c.magenta>仅通过反斜线符号和点的部分</c>


137
00:07:37,257 --> 00:07:39,059 line:90%,end
<c.magenta>键径可以依次形成</c>


138
00:07:39,126 --> 00:07:41,862 line:90%,end
<c.magenta>就像是属性接着属性地调用</c>


139
00:07:42,663 --> 00:07:46,066 line:90%,end
<c.magenta>很快地 任选链接会像它</c>
<c.magenta>对于属性那样工作</c>


140
00:07:49,469 --> 00:07:52,105 line:90%,end
<c.magenta>我们很快会允许通过下标的间接使用</c>


141
00:07:55,409 --> 00:07:56,877 line:90%,end
<c.magenta>就像是这样 我也喜欢</c>


142
00:08:00,214 --> 00:08:02,249 line:90%,end
<c.magenta>键径也可以从一个下标直接开始</c>


143
00:08:02,316 --> 00:08:05,652 line:90%,end
<c.magenta>这里我们从数据的字节下标开始</c>


144
00:08:05,719 --> 00:08:08,222 line:90%,end
<c.magenta>这里我们用startIndex表示</c>


145
00:08:09,223 --> 00:08:11,692 line:90%,end
<c.magenta>当然了 这也可以被推断</c>


146
00:08:11,758 --> 00:08:14,828 line:90%,end
<c.magenta>通过反斜线符号与点剩余部分</c>
<c.magenta>来保持一致性</c>


147
00:08:15,896 --> 00:08:19,967 line:90%,end
<c.magenta>这些新键径表达式给所有</c>
<c.magenta>Swift类型提供了一致的语法</c>


148
00:08:20,033 --> 00:08:23,070 line:90%,end
<c.magenta>对于支持属性</c>
<c.magenta>无论是保存的还是计算的</c>


149
00:08:24,271 --> 00:08:27,808 line:90%,end
<c.magenta>当然了 生成键径是一回事</c>
<c.magenta>但我们如何使用它们呢？</c>


150
00:08:28,342 --> 00:08:30,143 line:90%,end
<c.magenta>假设我们有一个键径</c>


151
00:08:32,246 --> 00:08:33,780 line:90%,end
<c.magenta>这里是一个孩子的年龄</c>


152
00:08:34,280 --> 00:08:37,851 line:90%,end
<c.magenta>使用键径来读取一个属性</c>
<c.magenta>就像是调用下标一样简单</c>


153
00:08:40,053 --> 00:08:41,154 line:90%,end
<c.magenta>这开始像是代码</c>


154
00:08:41,221 --> 00:08:43,423 line:90%,end
<c.magenta>我现在会高亮句法</c>


155
00:08:44,558 --> 00:08:45,592 line:90%,end
<c.magenta>好了</c>


156
00:08:46,426 --> 00:08:47,895 line:90%,end
<c.magenta>这里发生了些什么 我想要谈谈</c>


157
00:08:47,961 --> 00:08:51,598 line:90%,end
<c.magenta>一些背景动机</c>
<c.magenta>为什么它看起来是这个样子</c>


158
00:08:51,798 --> 00:08:55,669 line:90%,end
<c.magenta>首先我们给键径下标参数一个标签</c>


159
00:08:55,936 --> 00:08:58,438 line:90%,end
<c.magenta>我们这样做是因为我们想让它</c>
<c.magenta>不会与其他下标产生歧义</c>


160
00:08:58,505 --> 00:09:00,007 line:90%,end
<c.magenta>对于其他类型可以存在的下标</c>


161
00:09:00,307 --> 00:09:02,376 line:90%,end
<c.magenta>接着 你正在使用的值类型</c>


162
00:09:02,442 --> 00:09:05,979 line:90%,end
<c.magenta>它在调用下标</c>
<c.magenta>需要与键径的基类型相匹配</c>


163
00:09:06,580 --> 00:09:08,549 line:90%,end
<c.magenta>如果它们匹配 这是合理的事</c>


164
00:09:08,615 --> 00:09:10,484 line:90%,end
<c.magenta>你的代码就会编译</c>


165
00:09:12,419 --> 00:09:16,623 line:90%,end
<c.magenta>你也可以用下标来变动一个特定的值</c>


166
00:09:17,257 --> 00:09:20,694 line:90%,end
<c.magenta>下标非常好 因为它们提供了</c>
<c.magenta>一个快速对称的句法</c>


167
00:09:20,761 --> 00:09:21,828 line:90%,end
<c.magenta>来读取和写入一个值</c>


168
00:09:21,895 --> 00:09:24,064 line:90%,end
<c.magenta>无论它们是一个值类型还是引用类型</c>


169
00:09:25,065 --> 00:09:27,501 line:90%,end
<c.magenta>我已经展示了引用类型的情况</c>


170
00:09:27,568 --> 00:09:30,404 line:90%,end
<c.magenta>现在我想要换成展示</c>
<c.magenta>它们如何跟值类型协同运作的</c>


171
00:09:30,637 --> 00:09:32,406 line:90%,end
<c.magenta>为了这个目的 我们会扩展例子</c>


172
00:09:32,472 --> 00:09:33,974 line:90%,end
<c.magenta>到我真正想谈的地方</c>


173
00:09:34,041 --> 00:09:35,709 line:90%,end
<c.magenta>也就是生日派对计划</c>


174
00:09:37,244 --> 00:09:38,879 line:90%,end
<c.magenta>让我们创建一个派对</c>


175
00:09:39,513 --> 00:09:42,850 line:90%,end
<c.magenta>看起来本基要举办一个</c>
<c.magenta>建造主题的生日派对</c>


176
00:09:42,916 --> 00:09:45,018 line:90%,end
<c.magenta>通过一个键径来读取值类型</c>


177
00:09:45,085 --> 00:09:48,522 line:90%,end
<c.magenta>使用了和我们之前看到的</c>
<c.magenta>引入类型相同的下标句法</c>


178
00:09:49,122 --> 00:09:53,393 line:90%,end
<c.magenta>类似地 改动一个派对</c>
<c.magenta>也是使用相同的下标句法</c>


179
00:09:53,460 --> 00:09:56,230 line:90%,end
<c.magenta>这是个常见的主题</c>
<c.magenta>句法真的是一致的</c>


180
00:09:56,897 --> 00:10:01,201 line:90%,end
<c.magenta>然而既然这是Swift</c>
<c.magenta>我们知道本的派对是一个生日派对</c>


181
00:10:01,268 --> 00:10:03,403 line:90%,end
<c.magenta>因此语言可以为我们推断这一点</c>


182
00:10:04,771 --> 00:10:07,875 line:90%,end
<c.magenta>我刚听说本</c>
<c.magenta>又想改他生日派对的主题了</c>


183
00:10:07,941 --> 00:10:09,510 line:90%,end
<c.magenta>那么我们就在这里改过来吧</c>


184
00:10:10,744 --> 00:10:12,713 line:90%,end
<c.magenta>这里我高亮了一下句法</c>


185
00:10:12,846 --> 00:10:15,249 line:90%,end
<c.magenta>像是这样的代码</c>
<c.magenta>你只会调用属性</c>


186
00:10:15,315 --> 00:10:19,086 line:90%,end
<c.magenta>所以让我们看看当你使用这些键径</c>
<c.magenta>表达式的时候实际发生了什么吧</c>


187
00:10:21,755 --> 00:10:24,558 line:90%,end
<c.magenta>键径表达式</c>
<c.magenta>实际上生成了真正的值</c>


188
00:10:24,625 --> 00:10:26,527 line:90%,end
<c.magenta>像是所有的值 它们能被保存</c>


189
00:10:28,095 --> 00:10:29,963 line:90%,end
<c.magenta>那么 这个变量的类型是什么呢？</c>


190
00:10:30,030 --> 00:10:33,834 line:90%,end
<c.magenta>让我们假设使用Option加X键</c>
<c.magenta>就像是我们在Xcode中所能做的那样</c>


191
00:10:33,901 --> 00:10:37,004 line:90%,end
<c.magenta>不出意外 我们得到了</c>
<c.magenta>一个强类型的键径</c>


192
00:10:37,571 --> 00:10:40,874 line:90%,end
<c.magenta>其基类型是Kid</c>
<c.magenta>属性类型是String</c>


193
00:10:40,941 --> 00:10:42,476 line:90%,end
<c.magenta>因为昵称是字符串</c>


194
00:10:44,077 --> 00:10:46,880 line:90%,end
<c.magenta>强类型键径也可以适用于复合键径</c>


195
00:10:46,947 --> 00:10:48,849 line:90%,end
<c.magenta>这里我们从生日派对开始</c>


196
00:10:48,916 --> 00:10:51,118 line:90%,end
<c.magenta>一直遍历到庆祝者的年龄</c>


197
00:10:51,418 --> 00:10:54,354 line:90%,end
<c.magenta>当然了年龄是double类型</c>
<c.magenta>因为如果你不认识一个小孩子</c>


198
00:10:54,421 --> 00:10:57,057 line:90%,end
<c.magenta>小数点后的数字是非常重要的</c>


199
00:10:58,992 --> 00:11:01,929 line:90%,end
<c.magenta>变量所保存的键径</c>
<c.magenta>可以像字面量那样用</c>


200
00:11:06,066 --> 00:11:07,434 line:90%,end
<c.magenta>因为它们是强类型的</c>


201
00:11:07,501 --> 00:11:09,369 line:90%,end
<c.magenta>它们是静态被认知拥有正确类型的</c>


202
00:11:09,436 --> 00:11:11,171 line:90%,end
<c.magenta>这里是如我们所期望的double</c>


203
00:11:12,206 --> 00:11:14,675 line:90%,end
<c.magenta>假设我们要计划另一个生日派对</c>


204
00:11:14,741 --> 00:11:17,678 line:90%,end
<c.magenta>这次是米亚的</c>
<c.magenta>或者本的妹妹米亚</c>


205
00:11:18,612 --> 00:11:20,047 line:90%,end
<c.magenta>我们可以使用相同的键径变量</c>


206
00:11:20,113 --> 00:11:22,616 line:90%,end
<c.magenta>来找出她要庆祝的是哪个生日</c>


207
00:11:22,683 --> 00:11:26,653 line:90%,end
<c.magenta>通过这种方式 键径某种程度上</c>
<c.magenta>作为未执行属性调用来使用</c>


208
00:11:27,754 --> 00:11:30,390 line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我直接写入了庆祝者的年龄</c>


209
00:11:30,457 --> 00:11:32,492 line:90%,end
<c.magenta>但是让我们更进一步泛化一点</c>


210
00:11:33,126 --> 00:11:35,762 line:90%,end
<c.magenta>如果我想知道</c>
<c.magenta>任何跟一个派对有关的人的年龄呢？</c>


211
00:11:36,530 --> 00:11:38,532 line:90%,end
<c.magenta>我们要定义一个函数</c>


212
00:11:38,632 --> 00:11:41,168 line:90%,end
<c.magenta>把它叫做</c>
<c.magenta>partyPersonsAge函数</c>


213
00:11:41,235 --> 00:11:45,405 line:90%,end
<c.magenta>它们被给了一个派对和</c>
<c.magenta>参与者的键径并将返回他们的年龄</c>


214
00:11:45,672 --> 00:11:47,574 line:90%,end
<c.magenta>为了达成这个目的</c>
<c.magenta>我要展示另一个功能</c>


215
00:11:47,641 --> 00:11:49,810 line:90%,end
<c.magenta>这些类型安全的键径</c>


216
00:11:49,877 --> 00:11:53,547 line:90%,end
<c.magenta>可以动态地从其他键径生成新的键径</c>


217
00:11:53,881 --> 00:11:56,283 line:90%,end
<c.magenta>这里我会把两个键径连到一起</c>


218
00:11:56,350 --> 00:11:59,720 line:90%,end
<c.magenta>participantPath到孩子的年龄</c>
<c.magenta>同样 我们这里推断了是孩子</c>


219
00:11:59,786 --> 00:12:03,290 line:90%,end
<c.magenta>这就是为什么除了变量名</c>
<c.magenta>你都看不到“kid”这个词</c>


220
00:12:03,824 --> 00:12:06,326 line:90%,end
<c.magenta>如你所料</c>
<c.magenta>你会获得一个强类型的键径</c>


221
00:12:06,393 --> 00:12:08,662 line:90%,end
<c.magenta>从BirthdayParty开始</c>
<c.magenta>以Double结尾</c>


222
00:12:09,463 --> 00:12:13,367 line:90%,end
<c.magenta>用这个键径和存在变量中的</c>
<c.magenta>其他键径一样</c>


223
00:12:13,700 --> 00:12:15,369 line:90%,end
<c.magenta>我们可以在庆祝者中</c>
<c.magenta>调用我们的函数</c>


224
00:12:15,435 --> 00:12:18,172 line:90%,end
<c.magenta>我们可以得到和之前所见</c>
<c.magenta>完全相同的结果</c>


225
00:12:19,106 --> 00:12:22,209 line:90%,end
<c.magenta>当支持下标的时候</c>
<c.magenta>我们现在也可以使用这个函数</c>


226
00:12:22,276 --> 00:12:25,012 line:90%,end
<c.magenta>来找到派对的第一个到场者的年龄</c>


227
00:12:27,080 --> 00:12:30,050 line:90%,end
<c.magenta>现在我想要谈一些</c>
<c.magenta>关于附加键径的规则</c>


228
00:12:30,617 --> 00:12:34,288 line:90%,end
<c.magenta>当我们把两个键径连到一起时</c>
<c.magenta>就像我们把它们加到了一起</c>


229
00:12:35,556 --> 00:12:37,524 line:90%,end
<c.magenta>为了让这个相加能讲得通</c>


230
00:12:37,591 --> 00:12:40,327 line:90%,end
<c.magenta>我们需要看看</c>
<c.magenta>所涉及的键径的类型</c>


231
00:12:41,028 --> 00:12:44,231 line:90%,end
<c.magenta>我们需要看每个基类型</c>
<c.magenta>和每个属性类型</c>


232
00:12:45,966 --> 00:12:48,202 line:90%,end
<c.magenta>内部类型需要匹配</c>


233
00:12:48,302 --> 00:12:51,004 line:90%,end
<c.magenta>如果是这种情况的话</c>
<c.magenta>我们可以生成一个键径</c>


234
00:12:51,071 --> 00:12:54,341 line:90%,end
<c.magenta>从初始基类型到最终属性类型</c>


235
00:12:56,476 --> 00:13:00,080 line:90%,end
<c.magenta>这样 键径不在乎它们是如何获得</c>


236
00:13:00,147 --> 00:13:01,882 line:90%,end
<c.magenta>从它们的基类型到属性类型</c>


237
00:13:01,949 --> 00:13:04,618 line:90%,end
<c.magenta>它们能办到</c>
<c.magenta>而且编译器会为我们确保这一点</c>


238
00:13:06,019 --> 00:13:07,955 line:90%,end
<c.magenta>现在我想看看另一个例子</c>


239
00:13:08,021 --> 00:13:11,225 line:90%,end
<c.magenta>或者说Swift键径</c>
<c.magenta>所提供的类型安全性的另一个方面</c>


240
00:13:13,627 --> 00:13:14,995 line:90%,end
<c.magenta>以防你们还不是很清楚</c>


241
00:13:16,129 --> 00:13:18,398 line:90%,end
<c.magenta>假设我们想输出一个我们派对的概要</c>


242
00:13:18,532 --> 00:13:21,068 line:90%,end
<c.magenta>我们可以在键径中</c>
<c.magenta>生成一个label数组</c>


243
00:13:22,402 --> 00:13:25,539 line:90%,end
<c.magenta>但是我们会期望这个数组</c>
<c.magenta>partyPath什么呢</c>


244
00:13:25,606 --> 00:13:27,441 line:90%,end
<c.magenta>我们期望它的类型是什么呢？</c>


245
00:13:27,508 --> 00:13:29,109 line:90%,end
<c.magenta>毕竟主题是一个字符串</c>


246
00:13:29,476 --> 00:13:31,211 line:90%,end
<c.magenta>Attending是一个孩子的数组</c>


247
00:13:31,778 --> 00:13:34,081 line:90%,end
<c.magenta>celebrant</c>
<c.magenta>是对单独一个孩子的引用</c>


248
00:13:35,215 --> 00:13:36,717 line:90%,end
<c.magenta>这种情况下</c>
<c.magenta>我们获得了一个新类型</c>


249
00:13:36,783 --> 00:13:39,686 line:90%,end
<c.magenta>它是一个关于BirthdayParty的</c>
<c.magenta>PartialKeyPath数组</c>


250
00:13:40,220 --> 00:13:43,190 line:90%,end
<c.magenta>PartialKeyPath部分</c>
<c.magenta>是无类型键径</c>


251
00:13:43,557 --> 00:13:44,825 line:90%,end
<c.magenta>它们知道它们的基类型</c>


252
00:13:44,892 --> 00:13:50,597 line:90%,end
<c.magenta>但是它们可以指向任何对于</c>
<c.magenta>该基类型来说合法的键径</c>


253
00:13:50,664 --> 00:13:53,734 line:90%,end
<c.magenta>这样我们打印出报告</c>


254
00:13:54,368 --> 00:14:00,874 line:90%,end
<c.magenta>我们把titles和paths压缩到一起</c>
<c.magenta>使用partyPath来获取partyValue</c>


255
00:14:00,941 --> 00:14:02,176 line:90%,end
<c.magenta>然后打印我们的报告</c>


256
00:14:02,576 --> 00:14:04,578 line:90%,end
<c.magenta>你可以看到米亚要举办</c>
<c.magenta>一个太空主题的</c>


257
00:14:04,645 --> 00:14:06,480 line:90%,end
<c.magenta>看起来是个家庭生日派对</c>


258
00:14:06,547 --> 00:14:08,682 line:90%,end
<c.magenta>不过它是太空主题的</c>
<c.magenta>应该挺有意思</c>


259
00:14:11,218 --> 00:14:13,487 line:90%,end
<c.magenta>现在我想往BirthdayParty中</c>
<c.magenta>添加一个扩展</c>


260
00:14:13,687 --> 00:14:14,755 line:90%,end
<c.magenta>我们要添加一个函数</c>


261
00:14:14,821 --> 00:14:16,590 line:90%,end
<c.magenta>来让孩子们吹灭他们的生日蜡烛</c>


262
00:14:16,657 --> 00:14:17,724 line:90%,end
<c.magenta>这会和我们之前所做的</c>


263
00:14:17,791 --> 00:14:19,326 line:90%,end
<c.magenta>有点不一样</c>


264
00:14:19,393 --> 00:14:21,161 line:90%,end
<c.magenta>因为到目前为止</c>
<c.magenta>我们一直在读取键径</c>


265
00:14:21,228 --> 00:14:23,997 line:90%,end
<c.magenta>现在我想要写入到一个键径</c>
<c.magenta>或者使用键径来写入到一个值</c>


266
00:14:25,265 --> 00:14:26,567 line:90%,end
<c.magenta>我们要加入我们的函数</c>


267
00:14:27,000 --> 00:14:29,236 line:90%,end
<c.magenta>我想要指出的是</c>
<c.magenta>ageKeyPath实际上是一个新的类型</c>


268
00:14:29,303 --> 00:14:32,940 line:90%,end
<c.magenta>它是一个可写的键径</c>
<c.magenta>从BirthdayParty开始 以Double结尾</c>


269
00:14:34,374 --> 00:14:37,544 line:90%,end
<c.magenta>我们可以像是一般键径</c>
<c.magenta>那样来使用可写键径</c>


270
00:14:37,611 --> 00:14:39,913 line:90%,end
<c.magenta>从我们的值中得到想要的值</c>


271
00:14:40,480 --> 00:14:42,549 line:90%,end
<c.magenta>我们也可以使用它们来变动我们的值</c>


272
00:14:43,183 --> 00:14:45,352 line:90%,end
<c.magenta>我们终于要吹灭蜡烛了</c>


273
00:14:45,619 --> 00:14:48,155 line:90%,end
<c.magenta>除了一个问题</c>
<c.magenta>这一切看起来都很好</c>


274
00:14:48,789 --> 00:14:49,723 line:90%,end
<c.magenta>它不编译</c>


275
00:14:50,290 --> 00:14:51,859 line:90%,end
<c.magenta>这是个生日灾难</c>


276
00:14:53,861 --> 00:14:56,296 line:90%,end
<c.magenta>让我们尝试一下</c>
<c.magenta>我会现场解决这个问题</c>


277
00:14:56,964 --> 00:14:57,798 line:90%,end
<c.magenta>排除障碍</c>


278
00:14:58,832 --> 00:15:00,467 line:90%,end
<c.magenta>编译器告诉我们</c>


279
00:15:00,534 --> 00:15:03,237 line:90%,end
<c.magenta>“无法分配到不可改变的</c>
<c.magenta>表达类型Double”</c>


280
00:15:03,437 --> 00:15:05,372 line:90%,end
<c.magenta>这是非常Swift的风格</c>


281
00:15:06,173 --> 00:15:07,941 line:90%,end
<c.magenta>让我们看看能否知道到底是怎么回事</c>


282
00:15:08,041 --> 00:15:11,044 line:90%,end
<c.magenta>它说不可变的</c>
<c.magenta>但我们传的是一个可写的键径</c>


283
00:15:12,045 --> 00:15:13,981 line:90%,end
<c.magenta>我们确实传的是一个键径</c>


284
00:15:14,047 --> 00:15:17,050 line:90%,end
<c.magenta>让我们确定这个键径</c>
<c.magenta>实际上是个不可变的变量</c>


285
00:15:17,117 --> 00:15:19,586 line:90%,end
<c.magenta>有时候你应该用的是</c>
<c.magenta>var而你用的是let</c>


286
00:15:19,653 --> 00:15:21,255 line:90%,end
<c.magenta>让我们回到kid的声明</c>


287
00:15:21,321 --> 00:15:24,124 line:90%,end
<c.magenta>但我们看到的是var</c>
<c.magenta>我们的年龄的确是可变的</c>


288
00:15:24,391 --> 00:15:26,693 line:90%,end
<c.magenta>是var 所以没有问题</c>


289
00:15:27,528 --> 00:15:30,097 line:90%,end
<c.magenta>也许问题是写入本身</c>


290
00:15:30,163 --> 00:15:31,665 line:90%,end
<c.magenta>也就是我们用了subscript</c>


291
00:15:31,732 --> 00:15:33,667 line:90%,end
<c.magenta>我现在告诉你们</c>
<c.magenta>subscript是可以工作的</c>


292
00:15:33,734 --> 00:15:35,135 line:90%,end
<c.magenta>所以不是这个问题</c>


293
00:15:35,402 --> 00:15:37,504 line:90%,end
<c.magenta>肯定是self有什么问题</c>


294
00:15:38,472 --> 00:15:41,375 line:90%,end
<c.magenta>self是什么？</c>
<c.magenta>self是BirthdayParty的一个扩展</c>


295
00:15:41,441 --> 00:15:43,477 line:90%,end
<c.magenta>因此现在我们需要回到</c>
<c.magenta>BirthdayParty的声明</c>


296
00:15:43,544 --> 00:15:44,711 line:90%,end
<c.magenta>幸运的是 我们还有余地</c>


297
00:15:46,580 --> 00:15:48,949 line:90%,end
<c.magenta>我们会发现BirthdayParty</c>
<c.magenta>是一个结构体</c>


298
00:15:49,016 --> 00:15:50,417 line:90%,end
<c.magenta>而结构体是值类型的</c>


299
00:15:50,484 --> 00:15:52,452 line:90%,end
<c.magenta>因此这里编译器所做的是正确的</c>


300
00:15:52,519 --> 00:15:54,321 line:90%,end
<c.magenta>它不让我们变动BirthdayParty</c>


301
00:15:54,388 --> 00:15:57,724 line:90%,end
<c.magenta>因为我们的键径是</c>
<c.magenta>固定在BirthdayParty</c>


302
00:15:58,292 --> 00:15:59,526 line:90%,end
<c.magenta>我们能用的一个技巧就是</c>


303
00:15:59,593 --> 00:16:03,130 line:90%,end
<c.magenta>我们看看所知道的Swift的技巧</c>
<c.magenta>会发现</c>


304
00:16:03,197 --> 00:16:05,999 line:90%,end
<c.magenta>我们加上mutating就行了</c>
<c.magenta>一切都能正常运行了</c>


305
00:16:07,401 --> 00:16:09,203 line:90%,end
<c.magenta>但是当你这么做的时候</c>
<c.magenta>你会要停下来想想</c>


306
00:16:09,269 --> 00:16:11,004 line:90%,end
<c.magenta>这真的是正确的选择吗？</c>


307
00:16:11,238 --> 00:16:16,343 line:90%,end
<c.magenta>因为我们不想改动键</c>
<c.magenta>或者是BirthdayParty</c>


308
00:16:17,044 --> 00:16:18,111 line:90%,end
<c.magenta>我们要改动的是庆祝者</c>


309
00:16:18,178 --> 00:16:20,681 line:90%,end
<c.magenta>我刚检查过</c>
<c.magenta>BirthdayParty没有年龄</c>


310
00:16:21,081 --> 00:16:24,218 line:90%,end
<c.magenta>而庆祝者实际上是一个类</c>
<c.magenta>一个引用类型</c>


311
00:16:24,985 --> 00:16:27,321 line:90%,end
<c.magenta>对于这点 我们实际上有另一类键径</c>


312
00:16:27,387 --> 00:16:31,325 line:90%,end
<c.magenta>添加引入可变语义到变动中</c>


313
00:16:31,391 --> 00:16:33,527 line:90%,end
<c.magenta>它叫作引用可写键径</c>


314
00:16:34,695 --> 00:16:36,063 line:90%,end
<c.magenta>那么让我们使用它</c>


315
00:16:36,129 --> 00:16:37,431 line:90%,end
<c.magenta>这次编译通过了</c>


316
00:16:37,497 --> 00:16:39,466 line:90%,end
<c.magenta>我们可以最终声明我们的小男孩本基</c>


317
00:16:39,533 --> 00:16:42,236 line:90%,end
<c.magenta>大了一岁</c>
<c.magenta>尽管我觉得他现在叫本了</c>


318
00:16:43,270 --> 00:16:44,338 line:90%,end
<c.magenta>我们可以看看区别</c>


319
00:16:44,404 --> 00:16:46,874 line:90%,end
<c.magenta>在这两种变动键径的方法之间</c>


320
00:16:48,208 --> 00:16:49,977 line:90%,end
<c.magenta>我们有个</c>
<c.magenta>WritableKeyPath</c>


321
00:16:50,043 --> 00:16:53,547 line:90%,end
<c.magenta>WritableKeyPath</c>
<c.magenta>直接写入到它们的值类型base上</c>


322
00:16:53,881 --> 00:16:57,017 line:90%,end
<c.magenta>因此base或者链式的base</c>
<c.magenta>需要是可变动的</c>


323
00:16:58,719 --> 00:17:03,156 line:90%,end
<c.magenta>然而一个ReferenceWritableKeyPath</c>
<c.magenta>会在引用类型上调用一个属性setter</c>


324
00:17:03,557 --> 00:17:06,326 line:90%,end
<c.magenta>所有这些键径类型</c>
<c.magenta>生成了一个继承树</c>


325
00:17:07,794 --> 00:17:09,730 line:10%
<c.magenta>每个都比上一个更详细</c>


326
00:17:10,063 --> 00:17:11,565 line:10%
<c.magenta>这棵树最上面的根</c>


327
00:17:11,632 --> 00:17:13,666 line:10%
<c.magenta>是另一种我没有提到过的键径</c>


328
00:17:13,733 --> 00:17:16,837 line:10%
<c.magenta>叫作AnyKeyPath</c>
<c.magenta>这是一种完全无类型的键径</c>


329
00:17:17,003 --> 00:17:18,771 line:10%
<c.magenta>这对于你有键径时很有用</c>


330
00:17:18,839 --> 00:17:21,575 line:90%,end
<c.magenta>该键径是由多个base到</c>
<c.magenta>多个不同属性类型所组成</c>


331
00:17:21,642 --> 00:17:22,809 line:90%,end
<c.magenta>通常是一个集</c>


332
00:17:24,144 --> 00:17:26,380 line:90%,end
<c.magenta>如果这一切似乎有一点复杂</c>


333
00:17:26,445 --> 00:17:28,815 line:90%,end
<c.magenta>我向你保证</c>
<c.magenta>有关你想要的这种键径的规则</c>


334
00:17:28,882 --> 00:17:32,286 line:90%,end
<c.magenta>使用 还有获得</c>
<c.magenta>实际上很简单</c>


335
00:17:32,352 --> 00:17:34,421 line:90%,end
<c.magenta>还符合你已经熟悉的规则</c>


336
00:17:34,488 --> 00:17:37,524 line:90%,end
<c.magenta>关于Swift值类型和引用类型的</c>


337
00:17:38,725 --> 00:17:41,128 line:90%,end
<c.magenta>我们先解决一半问题</c>


338
00:17:41,328 --> 00:17:44,665 line:90%,end
<c.magenta>只读属性总会产生一个键径</c>


339
00:17:44,731 --> 00:17:46,466 line:90%,end
<c.magenta>（键径）</c>


340
00:17:46,767 --> 00:17:49,603 line:90%,end
<c.magenta>而可读写属性</c>
<c.magenta>事情就有些细微差别了</c>


341
00:17:50,938 --> 00:17:54,041 line:90%,end
<c.magenta>可变值类型base或者</c>
<c.magenta>链式可变值类型base</c>


342
00:17:54,107 --> 00:17:56,310 line:90%,end
<c.magenta>会生成一个</c>
<c.magenta>WritableKeyPath</c>


343
00:17:57,010 --> 00:18:01,515 line:90%,end
<c.magenta>WritableKeyPath</c>
<c.magenta>可以帮你更有效率地写入一个值类型</c>


344
00:18:02,382 --> 00:18:04,418 line:90%,end
<c.magenta>然而如果其中一个值类型</c>


345
00:18:05,519 --> 00:18:07,754 line:90%,end
<c.magenta>是不可变的 就像是一个let语句</c>


346
00:18:08,655 --> 00:18:10,190 line:90%,end
<c.magenta>该属性的可变性就消失了</c>


347
00:18:10,257 --> 00:18:13,026 line:90%,end
<c.magenta>就好像你使用一般属性的时候</c>


348
00:18:13,227 --> 00:18:14,828 line:90%,end
<c.magenta>你就剩下了KeyPath</c>


349
00:18:15,796 --> 00:18:17,564 line:90%,end
<c.magenta>最后讲个最简单的例子</c>


350
00:18:17,631 --> 00:18:19,733 line:90%,end
<c.magenta>在引入类型base上的可读写属性</c>


351
00:18:19,800 --> 00:18:22,102 line:90%,end
<c.magenta>总是生成</c>
<c.magenta>ReferenceWritableKeyPath</c>


352
00:18:23,704 --> 00:18:27,074 line:90%,end
<c.magenta>现在我想分享下关于</c>
<c.magenta>键径行为的最后一个细节</c>


353
00:18:28,108 --> 00:18:30,210 line:90%,end
<c.magenta>当我们和subscript一起</c>
<c.magenta>使用键径的时候</c>


354
00:18:30,277 --> 00:18:33,547 line:90%,end
<c.magenta>知道它们的行为和终结</c>
<c.magenta>有什么区别很重要</c>


355
00:18:34,648 --> 00:18:36,183 line:90%,end
<c.magenta>思考下面的例子</c>


356
00:18:36,550 --> 00:18:37,684 line:90%,end
<c.magenta>这里我要生成一个键径</c>


357
00:18:37,751 --> 00:18:39,686 line:90%,end
<c.magenta>来自于生日派对的第一个到场者</c>


358
00:18:40,153 --> 00:18:41,622 line:90%,end
<c.magenta>并且使用它来识别他们的年龄</c>


359
00:18:41,688 --> 00:18:45,692 line:90%,end
<c.magenta>使用我们前面的partyPersonAge方法</c>
<c.magenta>来识别他们的年龄</c>


360
00:18:46,226 --> 00:18:49,029 line:90%,end
<c.magenta>不出所料 这里我们得到的键径</c>


361
00:18:49,096 --> 00:18:51,732 line:90%,end
<c.magenta>是我们attendees数组</c>
<c.magenta>的第0个元素</c>


362
00:18:53,133 --> 00:18:54,835 line:90%,end
<c.magenta>假设我把序号变成了1</c>


363
00:18:54,902 --> 00:18:58,205 line:90%,end
<c.magenta>出于某种原因</c>
<c.magenta>我也关心第二个到场者的年龄</c>


364
00:18:59,506 --> 00:19:01,175 line:90%,end
<c.magenta>你可能会感到惊讶</c>


365
00:19:02,342 --> 00:19:04,978 line:90%,end
<c.magenta>结果键径没有变化</c>


366
00:19:05,045 --> 00:19:06,980 line:90%,end
<c.magenta>尽管我把序号改变了</c>


367
00:19:07,481 --> 00:19:10,450 line:90%,end
<c.magenta>通过这种方式</c>
<c.magenta>键径变得和终结不一样</c>


368
00:19:10,851 --> 00:19:12,286 line:90%,end
<c.magenta>它们由值所捕获</c>


369
00:19:12,452 --> 00:19:14,421 line:90%,end
<c.magenta>当这个功能变得可用时</c>


370
00:19:14,488 --> 00:19:16,957 line:90%,end
<c.magenta>我想要今天说以便你不会感到惊讶</c>


371
00:19:17,858 --> 00:19:18,825 line:90%,end
<c.magenta>我现在说了</c>


372
00:19:20,060 --> 00:19:24,698 line:90%,end
<c.magenta>到目前为止 我们已看了许多</c>
<c.magenta>关于这些类型安全键径的例子</c>


373
00:19:24,765 --> 00:19:29,670 line:90%,end
<c.magenta>满足了我们快速、类型安全以及</c>
<c.magenta>富于表现的属性遍历目标</c>


374
00:19:31,104 --> 00:19:32,906 line:90%,end
<c.magenta>我想要换个主题了</c>


375
00:19:32,973 --> 00:19:34,341 line:90%,end
<c.magenta>因为我想谈谈</c>
<c.magenta>这些键径是如何</c>


376
00:19:34,408 --> 00:19:37,010 line:90%,end
<c.magenta>被用来改进</c>
<c.magenta>目前Swift已存在的API的</c>


377
00:19:37,744 --> 00:19:39,446 line:90%,end
<c.magenta>特别是我想谈谈我们如何应用它们</c>


378
00:19:39,513 --> 00:19:40,781 line:90%,end
<c.magenta>到键值观察上</c>


379
00:19:42,349 --> 00:19:45,619 line:90%,end
<c.magenta>你们大概知道</c>
<c.magenta>KVO是Cocoa允许对象</c>


380
00:19:45,686 --> 00:19:49,022 line:90%,end
<c.magenta>建立状态变化通知关系的方式</c>


381
00:19:49,590 --> 00:19:52,292 line:90%,end
<c.magenta>如果你已经试着</c>
<c.magenta>用过目前Swift中的KVO</c>


382
00:19:52,359 --> 00:19:56,063 line:90%,end
<c.magenta>你大概知道它有点偏离预期了</c>


383
00:19:58,799 --> 00:20:00,868 line:90%,end
<c.magenta>假设我们有个引用</c>


384
00:20:02,536 --> 00:20:04,004 line:90%,end
<c.magenta>先别鼓掌 过会儿再鼓</c>


385
00:20:05,572 --> 00:20:08,175 line:90%,end
<c.magenta>假设我们有个对于</c>
<c.magenta>Objective-C值的引用</c>


386
00:20:08,242 --> 00:20:10,410 line:90%,end
<c.magenta>从前面例子里的小孩米亚</c>


387
00:20:10,477 --> 00:20:13,180 line:90%,end
<c.magenta>我们关心这个孩子的年龄变化</c>


388
00:20:14,348 --> 00:20:18,185 line:90%,end
<c.magenta>我们认为形成一个观察</c>
<c.magenta>应该像这样简单</c>


389
00:20:18,252 --> 00:20:19,119 line:90%,end
<c.magenta>现在鼓掌吧</c>


390
00:20:25,092 --> 00:20:27,361 line:90%,end
<c.magenta>我想要说明这个形成过程的一些细节</c>


391
00:20:27,861 --> 00:20:31,164 line:90%,end
<c.magenta>我们要在值类型上</c>
<c.magenta>直接生成我们的observation</c>


392
00:20:31,431 --> 00:20:33,333 line:90%,end
<c.magenta>使用我们新的类型安全键径</c>


393
00:20:34,067 --> 00:20:35,302 line:90%,end
<c.magenta>我们得到的是一个类似于</c>


394
00:20:35,369 --> 00:20:38,505 line:90%,end
<c.magenta>我们Notification Center API的</c>
<c.magenta>observation token</c>


395
00:20:38,572 --> 00:20:40,941 line:90%,end
<c.magenta>这个observation token</c>
<c.magenta>做了两件事</c>


396
00:20:41,008 --> 00:20:44,778 line:90%,end
<c.magenta>第一 它省去了我们</c>
<c.magenta>要处理不安全裸指针的麻烦</c>


397
00:20:44,845 --> 00:20:47,648 line:90%,end
<c.magenta>有着独一无二识别我们</c>
<c.magenta>observation的上下文环境</c>


398
00:20:47,881 --> 00:20:51,785 line:90%,end
<c.magenta>我们的observation直接联系着</c>
<c.magenta>我们返回得到的observation</c>


399
00:20:51,985 --> 00:20:54,721 line:90%,end
<c.magenta>第二 它管理了我们observation</c>
<c.magenta>的生命周期</c>


400
00:20:55,022 --> 00:20:57,558 line:90%,end
<c.magenta>如果我…我不能将它设成nil…</c>


401
00:20:57,624 --> 00:21:00,561 line:90%,end
<c.magenta>但是如果我把它设成nil</c>
<c.magenta>observation就会毁坏</c>


402
00:21:01,094 --> 00:21:03,430 line:90%,end
<c.magenta>这是个巨大的改进 而不是获得异常</c>


403
00:21:03,497 --> 00:21:06,700 line:90%,end
<c.magenta>当你忘了去除注册observation时</c>
<c.magenta>你的应用会崩溃</c>


404
00:21:07,968 --> 00:21:10,237 line:90%,end
<c.magenta>最后 这可能是最棒的部分</c>


405
00:21:10,304 --> 00:21:14,808 line:90%,end
<c.magenta>现在你可以利用终结来掌握</c>
<c.magenta>observation的反应</c>


406
00:21:15,108 --> 00:21:18,612 line:90%,end
<c.magenta>而不是嵌套if语句</c>
<c.magenta>来检查和比较字符串</c>


407
00:21:19,112 --> 00:21:22,149 line:90%,end
<c.magenta>让我们看看这个终结里面的参数</c>


408
00:21:23,050 --> 00:21:25,986 line:90%,end
<c.magenta>它有两个参数</c>
<c.magenta>第一个是被观察的对象本身</c>


409
00:21:26,153 --> 00:21:29,590 line:90%,end
<c.magenta>这个是相同的引用 米亚</c>
<c.magenta>但我们将它作为参数来提供</c>


410
00:21:30,357 --> 00:21:33,694 line:90%,end
<c.magenta>来帮助你避免意外创建了保持循环</c>


411
00:21:34,862 --> 00:21:37,631 line:90%,end
<c.magenta>第二个参数是一个change对象</c>


412
00:21:37,698 --> 00:21:40,868 line:90%,end
<c.magenta>这和现存的KVO API很类似</c>
<c.magenta>只不过</c>


413
00:21:40,934 --> 00:21:42,703 line:90%,end
<c.magenta>如果你用过 如果你熟悉那个API</c>


414
00:21:42,769 --> 00:21:44,571 line:90%,end
<c.magenta>你就会知道那是个松类型词典</c>


415
00:21:44,638 --> 00:21:46,773 line:90%,end
<c.magenta>而这里我们提供的是强类型结构体</c>


416
00:21:46,840 --> 00:21:49,109 line:90%,end
<c.magenta>因为键径 我们知道</c>
<c.magenta>observed是Kid 而且我们知道</c>


417
00:21:49,176 --> 00:21:52,212 line:90%,end
<c.magenta>因为键径 我们知道</c>
<c.magenta>变化的年龄是double类型</c>


418
00:21:52,479 --> 00:21:54,448 line:90%,end
<c.magenta>现在我想让这变得真实一点</c>


419
00:21:54,515 --> 00:21:55,582 line:90%,end
<c.magenta>我们会举个例子</c>


420
00:21:55,816 --> 00:21:58,552 line:90%,end
<c.magenta>假设我们有个控制器</c>
<c.magenta>检测孩子什么时候长大</c>


421
00:21:58,619 --> 00:22:00,287 line:90%,end
<c.magenta>叫做KindergartenController</c>


422
00:22:00,354 --> 00:22:03,223 line:90%,end
<c.magenta>它有一个键值 可观察属性</c>


423
00:22:03,390 --> 00:22:06,059 line:90%,end
<c.magenta>叫做representedKid</c>
<c.magenta>我们要生成一个observation</c>


424
00:22:06,126 --> 00:22:09,329 line:90%,end
<c.magenta>让我们添加一个var i</c>
<c.magenta>给我们的observation</c>


425
00:22:10,230 --> 00:22:12,099 line:90%,end
<c.magenta>接着我们现在就要生成</c>
<c.magenta>observation</c>


426
00:22:12,165 --> 00:22:14,434 line:90%,end
<c.magenta>给我们的控制器</c>
<c.magenta>representedKid.age</c>


427
00:22:14,501 --> 00:22:16,103 line:90%,end
<c.magenta>我们将其存在var i上</c>


428
00:22:17,037 --> 00:22:19,139 line:90%,end
<c.magenta>我们加入我们超秘密业务逻辑</c>


429
00:22:19,206 --> 00:22:21,441 line:90%,end
<c.magenta>如果你看着觉得是错误的</c>


430
00:22:21,508 --> 00:22:23,277 line:90%,end
<c.magenta>我向你们保证</c>
<c.magenta>一旦你准备好去幼儿园</c>


431
00:22:23,343 --> 00:22:26,280 line:90%,end
<c.magenta>你总是准备好去幼儿园</c>
<c.magenta>所以实际上是正确的</c>


432
00:22:27,214 --> 00:22:28,182 line:90%,end
<c.magenta>就是这样了</c>


433
00:22:28,448 --> 00:22:30,817 line:90%,end
<c.magenta>这就是我们控制器的整个声明过程</c>


434
00:22:31,818 --> 00:22:33,187 line:90%,end
<c.magenta>没有必要给一个dnit</c>


435
00:22:33,253 --> 00:22:35,656 line:90%,end
<c.magenta>我抛弃或者毁坏了我的</c>
<c.magenta>observation</c>


436
00:22:35,722 --> 00:22:38,091 line:90%,end
<c.magenta>因为它联系着observation token</c>
<c.magenta>的生命周期</c>


437
00:22:38,158 --> 00:22:39,626 line:90%,end
<c.magenta>当控制器消失的时候</c>


438
00:22:39,693 --> 00:22:43,330 line:90%,end
<c.magenta>observation token也会消失</c>
<c.magenta>在幻灯片上也合适</c>


439
00:22:43,830 --> 00:22:44,765 line:10%
<c.magenta>接下来让我们</c>


440
00:22:45,732 --> 00:22:47,601 line:10%
<c.magenta>接下来让我们创建控制器</c>


441
00:22:48,702 --> 00:22:50,404 line:10%
<c.magenta>这里我们指向米亚</c>


442
00:22:50,470 --> 00:22:53,674 line:10%
<c.magenta>通过我们之前定义的函数</c>
<c.magenta>我们让米亚吹灭蜡烛</c>


443
00:22:53,740 --> 00:22:56,276 line:10%
<c.magenta>最终我们见识到了这些</c>
<c.magenta>新类型安全键径的能力</c>


444
00:22:56,343 --> 00:22:58,145 line:10%
<c.magenta>我们的小女孩长大了一岁</c>


445
00:23:00,480 --> 00:23:03,183 line:90%,end
<c.magenta>目前为止</c>
<c.magenta>我已经展示所有想要展示的内容</c>


446
00:23:03,250 --> 00:23:06,486 line:90%,end
<c.magenta>但我想绕回来再讲一次</c>
<c.magenta>字符串键径</c>


447
00:23:07,621 --> 00:23:09,489 line:90%,end
<c.magenta>这些会一直存在</c>


448
00:23:09,556 --> 00:23:12,192 line:90%,end
<c.magenta>而且它们对于过期API来说</c>
<c.magenta>仍然有用</c>


449
00:23:13,093 --> 00:23:14,895 line:90%,end
<c.magenta>坚持使用字符串</c>


450
00:23:15,963 --> 00:23:17,698 line:90%,end
<c.magenta>然而 从Swift 4开始</c>


451
00:23:18,999 --> 00:23:22,436 line:90%,end
<c.magenta>你可以使用这些新的高性能</c>
<c.magenta>类型安全的键径</c>


452
00:23:22,970 --> 00:23:24,137 line:90%,end
<c.magenta>我们将其引入到语言中</c>


453
00:23:24,204 --> 00:23:26,707 line:90%,end
<c.magenta>因为我们觉得它非常重要</c>


454
00:23:27,541 --> 00:23:30,344 line:90%,end
<c.magenta>随着时间发展</c>
<c.magenta>它们只会变得更加重要</c>


455
00:23:31,478 --> 00:23:33,847 line:90%,end
<c.magenta>我想请托尼回到台上来讨论下</c>


456
00:23:33,914 --> 00:23:36,416 line:90%,end
<c.magenta>我们今年引入到</c>
<c.magenta>Swift的另一个重要语言功能</c>


457
00:23:36,483 --> 00:23:37,351 line:90%,end
<c.magenta>谢谢</c>


458
00:23:43,156 --> 00:23:44,491 line:90%,end
<c.magenta>谢谢 迈克尔</c>


459
00:23:44,825 --> 00:23:47,528 line:90%,end
<c.magenta>接下来 我们要谈谈编码和解码</c>


460
00:23:48,762 --> 00:23:51,198 line:90%,end
<c.magenta>总的来说 编码和解码</c>


461
00:23:51,265 --> 00:23:55,836 line:90%,end
<c.magenta>是关于你本地和定制</c>
<c.magenta>Swift数据结构之间的转换</c>


462
00:23:55,903 --> 00:23:58,772 line:90%,end
<c.magenta>还有压缩的格式 特别是JSON</c>


463
00:23:59,606 --> 00:24:02,676 line:90%,end
<c.magenta>你们很多人都告诉我们</c>
<c.magenta>关于错误匹配的问题</c>


464
00:24:02,743 --> 00:24:05,979 line:90%,end
<c.magenta>在强类型语言Swift</c>


465
00:24:06,046 --> 00:24:09,516 line:90%,end
<c.magenta>和弱类型压缩数据类型</c>
<c.magenta>像是JSON之间</c>


466
00:24:10,517 --> 00:24:12,352 line:90%,end
<c.magenta>我们相信这个挑战的答案</c>


467
00:24:12,419 --> 00:24:15,255 line:90%,end
<c.magenta>是由语言本身开始</c>


468
00:24:15,556 --> 00:24:17,724 line:90%,end
<c.magenta>还利用了编译器</c>


469
00:24:17,791 --> 00:24:22,763 line:90%,end
<c.magenta>标准库 还有Foundation</c>
<c.magenta>来使得与JSON交互变得简单</c>


470
00:24:22,829 --> 00:24:26,266 line:90%,end
<c.magenta>而且给你提供了强大定制化的机会</c>


471
00:24:27,167 --> 00:24:29,436 line:90%,end
<c.magenta>让我们从一个例子开始</c>


472
00:24:30,904 --> 00:24:33,407 line:90%,end
<c.magenta>这里有一些来自我们最喜欢的网站之一</c>
<c.magenta>GitHub的JSON</c>


473
00:24:33,941 --> 00:24:35,576 line:90%,end
<c.magenta>这是请求信息的结果</c>


474
00:24:35,642 --> 00:24:37,945 line:90%,end
<c.magenta>关于一个档案的提交</c>


475
00:24:38,312 --> 00:24:39,680 line:90%,end
<c.magenta>这是相当标准的JSON</c>


476
00:24:40,080 --> 00:24:43,116 line:90%,end
<c.magenta>这是个JSON对象或者</c>
<c.magenta>我们叫它词典</c>


477
00:24:43,350 --> 00:24:45,752 line:90%,end
<c.magenta>它支持一个任意数字的键值对</c>


478
00:24:45,819 --> 00:24:48,589 line:90%,end
<c.magenta>在这里 名称 也就是一个字符串</c>


479
00:24:48,655 --> 00:24:52,326 line:90%,end
<c.magenta>邮件 也是个字符串</c>
<c.magenta>日期 是个字符串</c>


480
00:24:52,693 --> 00:24:55,863 line:90%,end
<c.magenta>原因当然是</c>
<c.magenta>JSON没有原生日期类型</c>


481
00:24:56,263 --> 00:25:01,268 line:90%,end
<c.magenta>但有很多种将日期编码成</c>
<c.magenta>JSON的转换方式</c>


482
00:25:01,335 --> 00:25:03,804 line:90%,end
<c.magenta>这个显然是ISO8601</c>


483
00:25:04,738 --> 00:25:07,741 line:90%,end
<c.magenta>如果我们要在Swift中</c>
<c.magenta>表示这个JSON</c>


484
00:25:08,008 --> 00:25:09,443 line:90%,end
<c.magenta>它会看起来非常不一样</c>


485
00:25:10,444 --> 00:25:14,982 line:90%,end
<c.magenta>例如 我们为它创建一个强类型</c>
<c.magenta>可能是叫编写者的结构体</c>


486
00:25:15,849 --> 00:25:18,218 line:90%,end
<c.magenta>这个结构体有三个属性</c>


487
00:25:18,285 --> 00:25:20,787 line:90%,end
<c.magenta>名称和邮件还是字符串</c>


488
00:25:20,854 --> 00:25:24,591 line:90%,end
<c.magenta>但日期如你所见</c>
<c.magenta>使用了Foundation的日期类型</c>


489
00:25:25,425 --> 00:25:26,927 line:90%,end
<c.magenta>这个原因很重要是因为</c>


490
00:25:26,994 --> 00:25:30,631 line:90%,end
<c.magenta>随着你与其他Cocoa SDK</c>
<c.magenta>以及API交互</c>


491
00:25:30,697 --> 00:25:35,469 line:90%,end
<c.magenta>你会发现日期是一种用来</c>
<c.magenta>表示时间里一点的类型</c>


492
00:25:36,236 --> 00:25:38,839 line:90%,end
<c.magenta>这就是我们遇到的挑战 对吧</c>


493
00:25:39,306 --> 00:25:43,110 line:90%,end
<c.magenta>我们如何转换顶层弱类型JSON</c>


494
00:25:43,343 --> 00:25:45,679 line:90%,end
<c.magenta>到底层的强类型Swift类型？</c>


495
00:25:46,480 --> 00:25:49,049 line:90%,end
<c.magenta>我们认为应该像这样简单</c>


496
00:25:49,149 --> 00:25:51,852 line:90%,end
<c.magenta>在你的结构体上采用一个协议</c>


497
00:25:51,919 --> 00:25:55,088 line:90%,end
<c.magenta>让编译器 标准库</c>
<c.magenta>还有Foundation</c>


498
00:25:55,155 --> 00:25:57,257 line:90%,end
<c.magenta>来为你做大部分的工作</c>


499
00:25:59,459 --> 00:26:00,327 line:90%,end
<c.magenta>谢谢</c>


500
00:26:04,097 --> 00:26:06,200 line:90%,end
<c.magenta>让我们把幻灯片转到实际代码</c>


501
00:26:06,767 --> 00:26:08,602 line:90%,end
<c.magenta>首先我要将</c>
<c.magenta>JSON转换为一个字符串</c>


502
00:26:08,669 --> 00:26:12,206 line:90%,end
<c.magenta>用Swift 4中很酷的新文本句法</c>
<c.magenta>三重双引号</c>


503
00:26:12,439 --> 00:26:15,042 line:90%,end
<c.magenta>接着利用UTF-8编码</c>
<c.magenta>将这个字符串转换成数据</c>


504
00:26:15,108 --> 00:26:16,743 line:90%,end
<c.magenta>这对于JSON来说很常见</c>


505
00:26:16,844 --> 00:26:18,779 line:90%,end
<c.magenta>当然了 结构体编写者保持不变</c>


506
00:26:19,279 --> 00:26:22,249 line:10%
<c.magenta>接下来 我们创建一个解码器</c>
<c.magenta>它实际上做了</c>


507
00:26:22,316 --> 00:26:25,719 line:10%
<c.magenta>JSON和Swift结构间的转换</c>


508
00:26:27,287 --> 00:26:31,191 line:10%
<c.magenta>我们告诉解码器这个转换</c>
<c.magenta>ISO8601日期</c>


509
00:26:31,425 --> 00:26:33,060 line:10%
<c.magenta>我们后面再说</c>


510
00:26:33,493 --> 00:26:36,663 line:10%
<c.magenta>最后我们请求解码器</c>
<c.magenta>来解码一个编写者</c>


511
00:26:36,997 --> 00:26:39,399 line:10%
<c.magenta>结果不是任意的</c>
<c.magenta>它不是一个词典</c>


512
00:26:39,466 --> 00:26:42,236 line:10%
<c.magenta>你不需要检查字符串或者键值</c>


513
00:26:42,436 --> 00:26:45,405 line:10%
<c.magenta>它已经是这种情况下</c>
<c.magenta>你想要用的类型了</c>


514
00:26:46,773 --> 00:26:47,908 line:90%,end
<c.magenta>这很简单</c>


515
00:26:48,175 --> 00:26:50,344 line:90%,end
<c.magenta>让我们把难度提升一点</c>


516
00:26:50,644 --> 00:26:53,013 line:90%,end
<c.magenta>这个JSON实际上</c>
<c.magenta>是更大JSON集合的一部分</c>


517
00:26:53,080 --> 00:26:57,384 line:90%,end
<c.magenta>伴随着这个请求的结果</c>
<c.magenta>包括像是URL</c>


518
00:26:57,451 --> 00:26:59,720 line:90%,end
<c.magenta>额外的字符串和整型值</c>


519
00:27:00,387 --> 00:27:03,190 line:90%,end
<c.magenta>Swift中 我们照着做就可以</c>


520
00:27:03,357 --> 00:27:06,793 line:90%,end
<c.magenta>我要将我的结构体编写者嵌套到</c>
<c.magenta>一个叫做Commit的新结构体</c>


521
00:27:06,860 --> 00:27:08,028 line:90%,end
<c.magenta>也是可编码性</c>


522
00:27:08,595 --> 00:27:11,331 line:90%,end
<c.magenta>你会发现我可以用</c>
<c.magenta>Foundation的URL类型</c>


523
00:27:11,732 --> 00:27:13,066 line:90%,end
<c.magenta>还有我们的结构体编写者</c>


524
00:27:13,133 --> 00:27:15,402 line:90%,end
<c.magenta>你会发现我们能递归地向下降类型</c>


525
00:27:15,469 --> 00:27:17,804 line:90%,end
<c.magenta>如果它们也遵从可编码的规则</c>
<c.magenta>来解码它们</c>


526
00:27:18,539 --> 00:27:21,108 line:90%,end
<c.magenta>信息这个字符串</c>


527
00:27:21,175 --> 00:27:22,643 line:90%,end
<c.magenta>还有我们的</c>
<c.magenta>comment_count属性</c>


528
00:27:23,310 --> 00:27:26,146 line:90%,end
<c.magenta>要解码这个 只需要一行代码</c>


529
00:27:26,213 --> 00:27:27,881 line:90%,end
<c.magenta>这次我们要解码一个提交</c>


530
00:27:28,215 --> 00:27:31,351 line:10%
<c.magenta>结果是：我们的强Swift类型</c>
<c.magenta>让我们使用</c>


531
00:27:31,418 --> 00:27:33,787 line:10%
<c.magenta>我们知道并且喜欢的</c>
<c.magenta>Swift语言功能</c>


532
00:27:33,854 --> 00:27:36,356 line:10%
<c.magenta>来从压缩数据中得到我们想要的值</c>


533
00:27:36,423 --> 00:27:38,358 line:10%
<c.magenta>在这里 就是属性访问</c>


534
00:27:39,893 --> 00:27:41,161 line:10%
<c.magenta>让我们看看发生了什么</c>


535
00:27:41,595 --> 00:27:45,132 line:90%,end
<c.magenta>首先 可编码协议</c>
<c.magenta>实际上不是一个协议 是两个</c>


536
00:27:45,599 --> 00:27:49,903 line:90%,end
<c.magenta>第一个叫作Encodable</c>
<c.magenta>有一个函数encode to encoder</c>


537
00:27:50,637 --> 00:27:54,942 line:90%,end
<c.magenta>这个函数的目的是</c>
<c.magenta>允许类型告诉编码器</c>


538
00:27:55,008 --> 00:27:56,510 line:90%,end
<c.magenta>它需要的所有信息</c>


539
00:27:56,577 --> 00:27:58,645 line:90%,end
<c.magenta>以便接下来可以重建自己</c>


540
00:27:59,546 --> 00:28:03,050 line:10%
<c.magenta>相应的协议 可解码性</c>
<c.magenta>有一个初始化</c>


541
00:28:03,684 --> 00:28:07,187 line:10%
<c.magenta>初始化的目的是</c>
<c.magenta>允许类型来获得其所需要的值</c>


542
00:28:07,254 --> 00:28:09,756 line:10%
<c.magenta>从解码器中 接着使用这些值</c>


543
00:28:09,823 --> 00:28:14,228 line:10%
<c.magenta>来创建一个可供随时使用的</c>
<c.magenta>其自身完全初始化的实例</c>


544
00:28:16,496 --> 00:28:18,599 line:90%,end
<c.magenta>这些API的主要设计点</c>


545
00:28:18,665 --> 00:28:22,336 line:90%,end
<c.magenta>是使用你可能已经熟悉的</c>
<c.magenta>Swift行为</c>


546
00:28:22,402 --> 00:28:24,538 line:90%,end
<c.magenta>这叫作协议扩展</c>


547
00:28:24,771 --> 00:28:31,144 line:90%,end
<c.magenta>Swift中 协议不仅可定义接口</c>
<c.magenta>还可以藉由扩展</c>


548
00:28:31,211 --> 00:28:34,882 line:90%,end
<c.magenta>它们可以为该接口</c>
<c.magenta>提供一个默认的实现</c>


549
00:28:35,983 --> 00:28:38,886 line:90%,end
<c.magenta>它们让你给两者之一写你自己的实现</c>


550
00:28:38,952 --> 00:28:41,955 line:90%,end
<c.magenta>或者给整个协议来定制行为</c>


551
00:28:42,656 --> 00:28:45,225 line:90%,end
<c.magenta>让我们回到提交看看这是如何运作的</c>


552
00:28:46,126 --> 00:28:47,861 line:90%,end
<c.magenta>当我采用可编码的协议时</c>


553
00:28:47,928 --> 00:28:51,665 line:90%,end
<c.magenta>编译器会生成encode to encoder</c>
<c.magenta>的一个实现</c>


554
00:28:51,732 --> 00:28:54,368 line:90%,end
<c.magenta>还有init from decoder完全免费</c>


555
00:28:55,202 --> 00:28:57,571 line:90%,end
<c.magenta>在这种情况下</c>
<c.magenta>我不需要定制关于它们的任何东西</c>


556
00:28:57,638 --> 00:29:00,574 line:90%,end
<c.magenta>因此我可以从类型中完全移除它们</c>


557
00:29:01,775 --> 00:29:04,178 line:90%,end
<c.magenta>不过有一个是我想要定制的</c>


558
00:29:04,244 --> 00:29:06,480 line:90%,end
<c.magenta>就是这个属性的名字</c>


559
00:29:06,813 --> 00:29:09,149 line:90%,end
<c.magenta>你可以注意到它使用了蛇型连字符</c>


560
00:29:09,216 --> 00:29:10,717 line:90%,end
<c.magenta>这在JSON中很常见</c>


561
00:29:10,784 --> 00:29:13,153 line:90%,end
<c.magenta>但是这不符合Swift的命名规范</c>


562
00:29:13,587 --> 00:29:15,622 line:90%,end
<c.magenta>让我给你们展示下如何修复这个问题</c>


563
00:29:15,822 --> 00:29:18,725 line:90%,end
<c.magenta>首先 编译器还为我们</c>
<c.magenta>生成了一个东西</c>


564
00:29:18,792 --> 00:29:21,662 line:90%,end
<c.magenta>就是这个叫CodingKeys</c>
<c.magenta>的私有枚举</c>


565
00:29:23,363 --> 00:29:27,100 line:90%,end
<c.magenta>这个枚举由字符串组成</c>
<c.magenta>采用了CodingKey协议</c>


566
00:29:27,167 --> 00:29:29,102 line:90%,end
<c.magenta>同样我们稍后再讲</c>


567
00:29:29,236 --> 00:29:33,040 line:90%,end
<c.magenta>有趣的是这个枚举</c>
<c.magenta>有四个case语句</c>


568
00:29:33,106 --> 00:29:35,709 line:90%,end
<c.magenta>匹配我的四个属性的名字</c>


569
00:29:36,243 --> 00:29:39,146 line:90%,end
<c.magenta>为了定制我的属性的名字</c>


570
00:29:39,213 --> 00:29:41,615 line:90%,end
<c.magenta>我只需要定制case语句的名字</c>


571
00:29:42,015 --> 00:29:43,083 line:90%,end
<c.magenta>为了实现这个</c>


572
00:29:43,150 --> 00:29:47,387 line:90%,end
<c.magenta>我要将这个comment_count</c>
<c.magenta>从蛇型换成骆驼型</c>


573
00:29:47,888 --> 00:29:52,492 line:90%,end
<c.magenta>但是如你所见</c>
<c.magenta>我仍然对所读的JSON是兼容的</c>


574
00:29:52,559 --> 00:29:54,494 line:90%,end
<c.magenta>通过将该case的字符串值设置成</c>


575
00:29:54,561 --> 00:29:57,631 line:90%,end
<c.magenta>我们预期在压缩数据中找到的值</c>


576
00:29:58,232 --> 00:30:03,003 line:90%,end
<c.magenta>如果这就是我们需要做的所有定制</c>
<c.magenta>那么就完成了</c>


577
00:30:04,037 --> 00:30:08,408 line:90%,end
<c.magenta>你可以不再看了并且离开</c>
<c.magenta>但是在这个会议的结尾</c>


578
00:30:08,475 --> 00:30:10,210 line:90%,end
<c.magenta>我想给你们展示下我们能如何完成</c>


579
00:30:10,277 --> 00:30:12,779 line:90%,end
<c.magenta>对于这个提交的更多定制</c>


580
00:30:13,380 --> 00:30:15,682 line:90%,end
<c.magenta>现在我想把舞台交给同事毅太</c>


581
00:30:15,749 --> 00:30:17,784 line:90%,end
<c.magenta>来给我们实际演示一下这个东西</c>


582
00:30:28,028 --> 00:30:28,862 line:90%,end
<c.magenta>谢谢 托尼</c>


583
00:30:29,630 --> 00:30:33,567 line:90%,end
<c.magenta>托尼给你们展示了在你的类型中</c>
<c.magenta>采用可编码性是多么简单</c>


584
00:30:33,634 --> 00:30:35,669 line:90%,end
<c.magenta>不过让我们看看这会是什么样子</c>


585
00:30:35,736 --> 00:30:37,271 line:90%,end
<c.magenta>在许多你们的实践应用中</c>


586
00:30:38,438 --> 00:30:41,074 line:90%,end
<c.magenta>我这里有最近一直在做原型的小应用</c>


587
00:30:41,175 --> 00:30:42,776 line:90%,end
<c.magenta>因为我是Swift的大粉丝</c>


588
00:30:42,843 --> 00:30:44,745 line:90%,end
<c.magenta>我想要看有趣的git提交</c>


589
00:30:44,811 --> 00:30:46,780 line:90%,end
<c.magenta>出现在Swift的GitHub repo</c>


590
00:30:47,648 --> 00:30:51,518 line:90%,end
<c.magenta>这里我写了个小应用</c>
<c.magenta>与GitHub的JSON REST API交互</c>


591
00:30:51,585 --> 00:30:54,254 line:90%,end
<c.magenta>来解析这些提交</c>
<c.magenta>并通过一个表格视图来展示给我</c>


592
00:30:54,855 --> 00:30:57,758 line:90%,end
<c.magenta>让我们快看看把这个应用写完</c>
<c.magenta>是多么容易</c>


593
00:30:57,824 --> 00:30:59,326 line:90%,end
<c.magenta>使用新的可编码性API</c>


594
00:31:01,228 --> 00:31:03,463 line:90%,end
<c.magenta>如果我们切换到Xcode</c>
<c.magenta>你会注意到一些相同的模型</c>


595
00:31:03,530 --> 00:31:06,567 line:90%,end
<c.magenta>托尼在幻灯片上扩展了一点</c>


596
00:31:07,134 --> 00:31:10,337 line:90%,end
<c.magenta>我们有相同的提交信息 编写者信息</c>


597
00:31:10,871 --> 00:31:13,006 line:90%,end
<c.magenta>我们也做了同样的重命名</c>


598
00:31:13,774 --> 00:31:16,243 line:90%,end
<c.magenta>右侧是GitHub所提供的</c>
<c.magenta>JSON信息</c>


599
00:31:16,310 --> 00:31:18,545 line:90%,end
<c.magenta>不过有些不相关的部分被剪切掉了</c>


600
00:31:18,612 --> 00:31:20,314 line:10%
<c.magenta>如果你注意看右下角</c>


601
00:31:20,380 --> 00:31:23,884 line:10%
<c.magenta>在JSON代码中</c>
<c.magenta>有些是我们目前没有解码的信息</c>


602
00:31:24,451 --> 00:31:26,553 line:10%
<c.magenta>这没问题的 因为它会默认被忽略掉</c>


603
00:31:26,620 --> 00:31:28,222 line:10%
<c.magenta>我们接下来再处理它</c>


604
00:31:28,689 --> 00:31:31,959 line:90%,end
<c.magenta>让我们隐藏掉这个JSON代码</c>
<c.magenta>再深入看下我们的文件</c>


605
00:31:32,025 --> 00:31:34,127 line:90%,end
<c.magenta>来看看我们如何实际使用这些模型</c>


606
00:31:34,661 --> 00:31:37,197 line:90%,end
<c.magenta>这里我们有</c>
<c.magenta>CommitsViewController</c>


607
00:31:37,264 --> 00:31:41,001 line:90%,end
<c.magenta>这个是实际显示这些提交的</c>
<c.magenta>视图控制器在我们的表格视图中</c>


608
00:31:41,335 --> 00:31:43,871 line:90%,end
<c.magenta>这个视图控制器有我们的表格视图</c>


609
00:31:43,937 --> 00:31:45,572 line:90%,end
<c.magenta>还有这些提交的数组</c>


610
00:31:45,873 --> 00:31:49,176 line:90%,end
<c.magenta>注意这里是我们类型的一个数组</c>


611
00:31:49,409 --> 00:31:51,545 line:90%,end
<c.magenta>不是任何其他或者类似的数组</c>


612
00:31:53,013 --> 00:31:55,482 line:90%,end
<c.magenta>当我们要显示这个数据时</c>


613
00:31:55,549 --> 00:31:58,852 line:90%,end
<c.magenta>我们可以从GitHub获取数据</c>
<c.magenta>接着利用JSON解码器</c>


614
00:31:58,919 --> 00:32:00,320 line:90%,end
<c.magenta>就像托尼向你们演示的那样</c>


615
00:32:00,420 --> 00:32:03,924 line:90%,end
<c.magenta>我们可以请求将这些提交的数组</c>
<c.magenta>解码成我们的类型</c>


616
00:32:05,158 --> 00:32:08,462 line:10%
<c.magenta>一旦完成 我们可以重新加载</c>
<c.magenta>表格视图并显示它</c>


617
00:32:09,663 --> 00:32:12,566 line:10%
<c.magenta>如果出问题了 我们可以捕捉错误</c>


618
00:32:12,633 --> 00:32:14,735 line:10%
<c.magenta>并且显示一些本地信息给用户</c>


619
00:32:14,801 --> 00:32:16,870 line:10%
<c.magenta>高层面地告诉他们哪里出错了</c>


620
00:32:17,838 --> 00:32:19,706 line:10%
<c.magenta>这就是你如何将数据载入你的应用</c>


621
00:32:19,773 --> 00:32:21,942 line:10%
<c.magenta>让我们看看</c>
<c.magenta>它是怎么和我们的UI相关联的</c>


622
00:32:22,176 --> 00:32:24,144 line:10%
<c.magenta>往下一点看文件</c>


623
00:32:24,211 --> 00:32:26,847 line:10%
<c.magenta>我有一个辅助函数</c>
<c.magenta>来让我设置表格视图的单元格</c>


624
00:32:26,914 --> 00:32:29,049 line:10%
<c.magenta>在它们显示给用户之前</c>


625
00:32:29,116 --> 00:32:31,718 line:10%
<c.magenta>这里要设置我的定制表格视图单元格</c>


626
00:32:31,785 --> 00:32:34,454 line:10%
<c.magenta>我要从提交数组中抓取出一条提交</c>


627
00:32:34,688 --> 00:32:38,025 line:10%
<c.magenta>接着使用该条提交的强类型属性</c>


628
00:32:38,091 --> 00:32:39,560 line:10%
<c.magenta>我们就可以将其连接到UI</c>


629
00:32:39,660 --> 00:32:41,895 line:10%
<c.magenta>再次注意我们没有向下转换任何</c>


630
00:32:41,962 --> 00:32:44,131 line:10%
<c.magenta>而且没有通过数组或者词典配对</c>


631
00:32:44,198 --> 00:32:47,134 line:10%
<c.magenta>这就是我们写类型的方式</c>
<c.magenta>还有我们想要如何使用它</c>


632
00:32:48,669 --> 00:32:50,737 line:90%,end
<c.magenta>这都挺不错的</c>
<c.magenta>不过让我们回到我们的应用</c>


633
00:32:50,804 --> 00:32:53,607 line:90%,end
<c.magenta>你看这里就会发现</c>
<c.magenta>UI这里有一些空间</c>


634
00:32:53,674 --> 00:32:57,144 line:90%,end
<c.magenta>我留下来连接给</c>
<c.magenta>每个提交所对应的哈希值的</c>


635
00:32:57,211 --> 00:32:59,880 line:90%,end
<c.magenta>但它还没被连接上</c>
<c.magenta>让我们现在完成它</c>


636
00:33:02,049 --> 00:33:05,452 line:90%,end
<c.magenta>如果我们回到模型</c>
<c.magenta>重新打开JSON代码</c>


637
00:33:05,552 --> 00:33:10,023 line:90%,end
<c.magenta>我们会发现在JSON代码中</c>
<c.magenta>有个哈希属性</c>


638
00:33:10,090 --> 00:33:11,592 line:90%,end
<c.magenta>我们一直没有请求</c>


639
00:33:11,758 --> 00:33:13,660 line:90%,end
<c.magenta>让我们把它加到我们的类型里</c>


640
00:33:13,927 --> 00:33:17,497 line:90%,end
<c.magenta>接着 如果我构建项目来使用它</c>


641
00:33:17,564 --> 00:33:20,000 line:90%,end
<c.magenta>你会发现我得到一个构建失败</c>


642
00:33:20,234 --> 00:33:22,002 line:90%,end
<c.magenta>让我们看看为什么会这样</c>


643
00:33:23,203 --> 00:33:26,607 line:90%,end
<c.magenta>作为这个类型的一部分</c>
<c.magenta>我已创建了一个定制CodingKeys枚举</c>


644
00:33:26,807 --> 00:33:29,209 line:90%,end
<c.magenta>这个你放进类型里的</c>
<c.magenta>CodingKeys枚举</c>


645
00:33:29,276 --> 00:33:32,646 line:90%,end
<c.magenta>是用来控制编译器生成的强大工具</c>


646
00:33:32,713 --> 00:33:35,516 line:90%,end
<c.magenta>作为NNCode 2初始的一部分</c>


647
00:33:35,949 --> 00:33:38,118 line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我提供了一个CodingKeys枚举</c>


648
00:33:38,185 --> 00:33:42,623 line:90%,end
<c.magenta>来将我的提交信息属性重命名</c>
<c.magenta>以匹配JSON里的内容</c>


649
00:33:43,023 --> 00:33:45,659 line:90%,end
<c.magenta>但这里 我刚添加的哈希属性</c>


650
00:33:45,726 --> 00:33:47,194 line:90%,end
<c.magenta>在CodingKeys中找不到</c>


651
00:33:47,794 --> 00:33:49,596 line:90%,end
<c.magenta>编译器会试着做的是</c>


652
00:33:49,663 --> 00:33:52,966 line:90%,end
<c.magenta>如果你故意落下一个属性</c>
<c.magenta>没有写入CodingKeys枚举</c>


653
00:33:53,033 --> 00:33:57,037 line:90%,end
<c.magenta>它就会从编码和解码显示中移除出去</c>


654
00:33:57,237 --> 00:33:58,238 line:90%,end
<c.magenta>这里发生的是</c>


655
00:33:58,305 --> 00:34:01,842 line:90%,end
<c.magenta>因为这个哈希属性没有一个默认值</c>


656
00:34:01,909 --> 00:34:05,279 line:90%,end
<c.magenta>如果编译器试图给我们生成</c>
<c.magenta>一个初始化</c>


657
00:34:05,345 --> 00:34:08,348 line:90%,end
<c.magenta>就不会有合理的值初始化给这个属性</c>


658
00:34:08,415 --> 00:34:11,051 line:90%,end
<c.magenta>因此编译器拒绝这么做</c>
<c.magenta>那么我们就会得到构建失败</c>


659
00:34:11,118 --> 00:34:14,021 line:90%,end
<c.magenta>因为我们的类型实际上</c>
<c.magenta>没有遵从可解码性</c>


660
00:34:14,721 --> 00:34:16,590 line:90%,end
<c.magenta>在这个例子中 我们实际上不想让</c>


661
00:34:16,657 --> 00:34:18,992 line:90%,end
<c.magenta>这个哈希属性</c>
<c.magenta>从我们的编码表示中落下</c>


662
00:34:19,059 --> 00:34:20,127 line:90%,end
<c.magenta>我们想要解码它</c>


663
00:34:20,226 --> 00:34:22,496 line:90%,end
<c.magenta>让我们镜像这个相同的属性</c>


664
00:34:22,629 --> 00:34:23,931 line:90%,end
<c.magenta>在我们的CodingKeys枚举中</c>


665
00:34:24,931 --> 00:34:27,801 line:90%,end
<c.magenta>让我们再次隐藏JSON代码</c>
<c.magenta>去连接这个属性</c>


666
00:34:27,868 --> 00:34:29,101 line:10%
<c.magenta>直接到我们的UI上</c>


667
00:34:29,436 --> 00:34:31,938 line:10%
<c.magenta>在这个单元格设置方法中</c>


668
00:34:32,005 --> 00:34:35,175 line:10%
<c.magenta>我们要加入另一行代码来抓取哈希值</c>


669
00:34:35,242 --> 00:34:38,212 line:10%
<c.magenta>我们将要把它变短一点</c>
<c.magenta>让它更加适合我们的UI</c>


670
00:34:38,277 --> 00:34:40,746 line:10%
<c.magenta>就像使用任何东西一样</c>
<c.magenta>使用强类型属性</c>


671
00:34:40,813 --> 00:34:42,616 line:10%
<c.magenta>我们可以将其直接连接到我们的UI</c>


672
00:34:43,016 --> 00:34:44,518 line:10%
<c.magenta>让我们回到我们的应用</c>


673
00:34:44,585 --> 00:34:47,387 line:10%
<c.magenta>看一下确保所有东西都连接正确了</c>


674
00:34:49,723 --> 00:34:51,757 line:90%,end
<c.magenta>这里我们已经重新运行了</c>


675
00:34:51,824 --> 00:34:54,161 line:90%,end
<c.magenta>我们可以看到所有东西</c>
<c.magenta>都连接到了我们的UI</c>


676
00:34:54,228 --> 00:34:57,130 line:90%,end
<c.magenta>我很高兴 因为这只用了四行代码</c>


677
00:34:57,197 --> 00:34:58,131 line:90%,end
<c.magenta>加到我们的应用中</c>


678
00:35:02,069 --> 00:35:02,903 line:90%,end
<c.magenta>谢谢</c>


679
00:35:06,473 --> 00:35:08,208 line:90%,end
<c.magenta>现在暂时回到代码中</c>


680
00:35:08,275 --> 00:35:11,912 line:90%,end
<c.magenta>让我们看看当应用出错时</c>
<c.magenta>我们都能干些什么</c>


681
00:35:13,013 --> 00:35:15,382 line:90%,end
<c.magenta>如果我们再一次打开JSON代码</c>


682
00:35:15,449 --> 00:35:16,917 line:90%,end
<c.magenta>你可能会注意到在右下角</c>


683
00:35:16,984 --> 00:35:19,386 line:90%,end
<c.magenta>我们还有最后一个</c>
<c.magenta>一直没有解码的属性</c>


684
00:35:19,453 --> 00:35:21,221 line:90%,end
<c.magenta>让我们现在完成它</c>


685
00:35:22,055 --> 00:35:24,658 line:90%,end
<c.magenta>我们要把URL属性加入到</c>
<c.magenta>我们的类型中</c>


686
00:35:24,725 --> 00:35:27,227 line:90%,end
<c.magenta>并且在CodingKeys枚举中</c>
<c.magenta>镜像它</c>


687
00:35:28,161 --> 00:35:31,231 line:90%,end
<c.magenta>这次让我们给CodingKey</c>
<c.magenta>一个值</c>


688
00:35:31,298 --> 00:35:34,368 line:90%,end
<c.magenta>明显在我们的JSON中是找不到的</c>


689
00:35:35,202 --> 00:35:37,738 line:90%,end
<c.magenta>当我们试图解码这个值的时候</c>


690
00:35:37,804 --> 00:35:41,341 line:90%,end
<c.magenta>它不会被找到</c>
<c.magenta>因此这会在解码时候变成一个错误</c>


691
00:35:42,109 --> 00:35:45,179 line:90%,end
<c.magenta>看看我们如何解决这个错误</c>
<c.magenta>让我们再把JSON代码隐藏起来</c>


692
00:35:45,245 --> 00:35:47,314 line:90%,end
<c.magenta>往下找到我们实现解码的地方</c>


693
00:35:48,615 --> 00:35:50,083 line:90%,end
<c.magenta>为了解决这个错误</c>


694
00:35:50,217 --> 00:35:53,620 line:90%,end
<c.magenta>我们可以捕捉一个解码错误</c>
<c.magenta>keyNotFound错误</c>


695
00:35:53,687 --> 00:35:56,823 line:90%,end
<c.magenta>这表明了我们试图访问</c>
<c.magenta>该键的某些内容</c>


696
00:35:56,890 --> 00:35:58,926 line:90%,end
<c.magenta>但它不能在加载内容的</c>
<c.magenta>任何地方被找到</c>


697
00:35:59,459 --> 00:36:01,595 line:90%,end
<c.magenta>除了这个</c>
<c.magenta>我们获得了一些上下文环境信息</c>


698
00:36:01,662 --> 00:36:03,163 line:90%,end
<c.magenta>关于什么以及哪里出了错</c>


699
00:36:03,697 --> 00:36:07,134 line:90%,end
<c.magenta>让我们在这设置一个断点</c>
<c.magenta>带着这个有错的键运行应用</c>


700
00:36:07,201 --> 00:36:09,336 line:90%,end
<c.magenta>看一下以确保我们可以捕捉到</c>
<c.magenta>这个错误</c>


701
00:36:09,403 --> 00:36:10,571 line:90%,end
<c.magenta>并且我们到达了断点</c>


702
00:36:11,805 --> 00:36:13,340 line:90%,end
<c.magenta>现在我们运行了这个应用</c>


703
00:36:13,407 --> 00:36:15,409 line:90%,end
<c.magenta>你会注意到我们确实到达了那个断点</c>


704
00:36:15,475 --> 00:36:18,278 line:90%,end
<c.magenta>如果我们打印这个键</c>
<c.magenta>你可以看到事实上</c>


705
00:36:18,345 --> 00:36:20,681 line:90%,end
<c.magenta>我们给了一个有错误数值的URL键</c>


706
00:36:20,747 --> 00:36:22,716 line:90%,end
<c.magenta>事实上 它在加载内容里找不到</c>


707
00:36:22,783 --> 00:36:24,051 line:90%,end
<c.magenta>因此我们得到了这个错误</c>


708
00:36:25,052 --> 00:36:26,820 line:90%,end
<c.magenta>这里我们如果看上下文环境信息</c>


709
00:36:26,887 --> 00:36:30,390 line:90%,end
<c.magenta>你可以看到两个有用的功能</c>
<c.magenta>来帮助你解决发生的问题</c>


710
00:36:31,091 --> 00:36:33,493 line:90%,end
<c.magenta>首先是一条排除故障描述</c>
<c.magenta>给作为开发者的你</c>


711
00:36:33,560 --> 00:36:36,930 line:90%,end
<c.magenta>来看看哪里出了问题 还有代码路径</c>


712
00:36:36,997 --> 00:36:40,367 line:90%,end
<c.magenta>其描述了在加载内容时哪里出了问题</c>
<c.magenta>导致这个地方出错</c>


713
00:36:41,602 --> 00:36:43,604 line:90%,end
<c.magenta>这些都很棒 不过事实上</c>


714
00:36:43,670 --> 00:36:47,040 line:90%,end
<c.magenta>如果我不是很关心URL</c>


715
00:36:47,107 --> 00:36:48,242 line:90%,end
<c.magenta>而且我可能不需要它</c>


716
00:36:48,308 --> 00:36:51,044 line:90%,end
<c.magenta>那么解决这个错误的一个方法</c>
<c.magenta>就是让你的URL变为可选</c>


717
00:36:52,312 --> 00:36:54,414 line:90%,end
<c.magenta>当你默认将这个属性设为可选时</c>


718
00:36:54,481 --> 00:36:56,583 line:90%,end
<c.magenta>如果键或值没有被找到</c>


719
00:36:56,650 --> 00:36:59,386 line:90%,end
<c.magenta>它会被初始化设为nil</c>


720
00:36:59,753 --> 00:37:01,788 line:90%,end
<c.magenta>让我们隐藏我们的UI</c>
<c.magenta>重新运行应用</c>


721
00:37:01,855 --> 00:37:03,857 line:90%,end
<c.magenta>来看看我们是不是还会达到断点</c>


722
00:37:05,058 --> 00:37:07,594 line:90%,end
<c.magenta>当我们重新运行时</c>
<c.magenta>我们不会再达到断点</c>


723
00:37:07,661 --> 00:37:10,864 line:90%,end
<c.magenta>因为该值被默认设成了nil</c>
<c.magenta>这是个不错的习惯</c>


724
00:37:11,865 --> 00:37:13,600 line:90%,end
<c.magenta>让我们回到代码并看一下</c>


725
00:37:13,667 --> 00:37:16,303 line:90%,end
<c.magenta>我们还可以捕捉哪些有用的错误</c>


726
00:37:17,137 --> 00:37:20,807 line:90%,end
<c.magenta>另一个错误像是</c>
<c.magenta>DecodingError.valueNotFound</c>


727
00:37:20,874 --> 00:37:23,844 line:90%,end
<c.magenta>其表明了我们试图解码</c>
<c.magenta>该类型的某些东西</c>


728
00:37:23,911 --> 00:37:25,145 line:90%,end
<c.magenta>但是实际上找到了nil</c>


729
00:37:25,979 --> 00:37:28,715 line:90%,end
<c.magenta>你还得到了相同的上下文环境信息</c>


730
00:37:28,782 --> 00:37:30,651 line:90%,end
<c.magenta>来告诉你什么以及哪里出了错</c>


731
00:37:32,386 --> 00:37:35,022 line:90%,end
<c.magenta>同时 你或许想捕捉类型不匹配</c>


732
00:37:35,255 --> 00:37:38,125 line:90%,end
<c.magenta>表明了你试图解码该类型的某些东西</c>


733
00:37:38,192 --> 00:37:40,160 line:90%,end
<c.magenta>但是在加载内容里找到的是别的类型</c>


734
00:37:40,227 --> 00:37:43,797 line:90%,end
<c.magenta>比如说 你试图解码一个字符串</c>
<c.magenta>而找到的是一个数字</c>


735
00:37:44,031 --> 00:37:47,100 line:90%,end
<c.magenta>同样 你会跟前面一样</c>
<c.magenta>得到相同的上下文环境信息</c>


736
00:37:48,101 --> 00:37:50,737 line:90%,end
<c.magenta>当你想排除故障时 这些错误很有用</c>


737
00:37:50,804 --> 00:37:53,073 line:90%,end
<c.magenta>当某些东西出错时 不过通常情况下</c>


738
00:37:53,140 --> 00:37:56,043 line:90%,end
<c.magenta>你不会想要在最高级别</c>
<c.magenta>就捕捉这些错误</c>


739
00:37:56,109 --> 00:37:57,744 line:90%,end
<c.magenta>取而代之 你只想要捕捉通用错误</c>


740
00:37:57,811 --> 00:38:00,247 line:90%,end
<c.magenta>并显示一些本地的信息</c>
<c.magenta>给用户以便他们可以想出</c>


741
00:38:00,314 --> 00:38:02,316 line:90%,end
<c.magenta>什么出错了或者报告这个漏洞</c>


742
00:38:03,450 --> 00:38:05,552 line:90%,end
<c.magenta>这些实际上是非常强大的工具</c>


743
00:38:05,619 --> 00:38:07,187 line:90%,end
<c.magenta>来实现一些更高级的事情</c>


744
00:38:07,487 --> 00:38:10,057 line:90%,end
<c.magenta>如果你定制你的init from</c>
<c.magenta>或者encode to</c>


745
00:38:10,123 --> 00:38:13,160 line:90%,end
<c.magenta>你可以捕捉类型里的这些错误</c>
<c.magenta>来实现强大的功能</c>


746
00:38:13,227 --> 00:38:17,064 line:90%,end
<c.magenta>像是数据迁移 重命名属性等等</c>


747
00:38:17,331 --> 00:38:19,099 line:90%,end
<c.magenta>但在我们的应用中</c>
<c.magenta>其实无需这么做</c>


748
00:38:19,166 --> 00:38:21,568 line:90%,end
<c.magenta>因为我已经通过少量代码</c>
<c.magenta>得到了我想要的功能</c>


749
00:38:22,002 --> 00:38:24,438 line:90%,end
<c.magenta>我要将舞台交还给托尼</c>
<c.magenta>让他来谈谈</c>


750
00:38:24,505 --> 00:38:27,975 line:90%,end
<c.magenta>一些更高级的编码和解码主题 谢谢</c>


751
00:38:33,313 --> 00:38:34,147 line:90%,end
<c.magenta>谢谢 毅太</c>


752
00:38:35,682 --> 00:38:40,254 line:90%,end
<c.magenta>让我们继续谈谈一些更高级的主题吧</c>


753
00:38:40,320 --> 00:38:41,788 line:90%,end
<c.magenta>关于编码和解码的</c>


754
00:38:41,855 --> 00:38:44,324 line:90%,end
<c.magenta>我们要谈谈我称之为三个支柱的</c>


755
00:38:44,391 --> 00:38:46,493 line:90%,end
<c.magenta>可编码性API设计哲学</c>


756
00:38:46,827 --> 00:38:50,230 line:90%,end
<c.magenta>首先是我们真的想要内置错误解决</c>


757
00:38:50,297 --> 00:38:51,598 line:90%,end
<c.magenta>像是你在演示中所看到的</c>


758
00:38:52,566 --> 00:38:54,501 line:90%,end
<c.magenta>当你在处理压缩数据的时候</c>


759
00:38:54,568 --> 00:38:59,039 line:90%,end
<c.magenta>处理未预见的输入不是如果的问题</c>
<c.magenta>而是什么时候的问题</c>


760
00:38:59,773 --> 00:39:02,976 line:90%,end
<c.magenta>这可能是数据侵蚀</c>
<c.magenta>可能是未预见的API变化</c>


761
00:39:03,043 --> 00:39:06,914 line:90%,end
<c.magenta>来自你接收数据的地方</c>
<c.magenta>或者甚至是恶意的输入</c>


762
00:39:06,980 --> 00:39:09,650 line:90%,end
<c.magenta>有些人试图探查到你应用的弱点</c>


763
00:39:09,750 --> 00:39:11,952 line:90%,end
<c.magenta>我们决定不应该有致命性的错误</c>


764
00:39:12,019 --> 00:39:13,987 line:90%,end
<c.magenta>作为解析不受信任数据的结果</c>


765
00:39:14,454 --> 00:39:17,658 line:90%,end
<c.magenta>然而我们确实在Swift中</c>
<c.magenta>使用致命性错误</c>


766
00:39:17,724 --> 00:39:20,194 line:90%,end
<c.magenta>若我们检测到这可能是开发者的错误</c>


767
00:39:20,394 --> 00:39:22,229 line:90%,end
<c.magenta>就会有一个含致命性错误的字符串</c>


768
00:39:22,296 --> 00:39:24,398 line:90%,end
<c.magenta>在告诉你哪里可能出错了</c>


769
00:39:24,998 --> 00:39:28,535 line:90%,end
<c.magenta>对于其他情况 我们使用</c>
<c.magenta>Swift内置的错误处理机制</c>


770
00:39:28,602 --> 00:39:32,072 line:90%,end
<c.magenta>这类错误在编码和解码时候</c>
<c.magenta>都有可能发生</c>


771
00:39:32,973 --> 00:39:34,374 line:90%,end
<c.magenta>让我们看看它们是什么样的</c>


772
00:39:35,108 --> 00:39:37,177 line:90%,end
<c.magenta>首先 编码</c>


773
00:39:37,411 --> 00:39:40,747 line:90%,end
<c.magenta>只有一种编码的错误 就是非法的值</c>


774
00:39:41,114 --> 00:39:43,650 line:90%,end
<c.magenta>对于某些像JSON这样的格式</c>


775
00:39:43,717 --> 00:39:47,921 line:90%,end
<c.magenta>我们想要给予它们灵活性来</c>
<c.magenta>处理它们可能没有预见到的输入</c>


776
00:39:47,988 --> 00:39:51,258 line:90%,end
<c.magenta>而不是报告一个致命性的错误</c>
<c.magenta>或是赋给某些默认值</c>


777
00:39:51,592 --> 00:39:55,829 line:90%,end
<c.magenta>例如在JSON中</c>
<c.magenta>非数或者无穷不是合法值</c>


778
00:39:56,063 --> 00:39:58,165 line:90%,end
<c.magenta>因此在这些情况下 它们能抛出错误</c>


779
00:39:58,232 --> 00:40:01,068 line:90%,end
<c.magenta>你可能从类型层面上做不了太多</c>


780
00:40:01,134 --> 00:40:02,703 line:90%,end
<c.magenta>不过你仍然可以在上层捕捉它</c>


781
00:40:02,769 --> 00:40:05,439 line:90%,end
<c.magenta>并且呈献给你的用户一个错误</c>
<c.magenta>或者防止其他种类的错误</c>


782
00:40:05,506 --> 00:40:07,808 line:90%,end
<c.magenta>或是呈现某种其他类型的恢复机制</c>


783
00:40:08,675 --> 00:40:12,279 line:90%,end
<c.magenta>对于解码方面 有四种错误</c>
<c.magenta>我们在演示中已经看到过三种了</c>


784
00:40:12,346 --> 00:40:14,348 line:90%,end
<c.magenta>类型不匹配 找不到的键</c>
<c.magenta>找不到的值</c>


785
00:40:14,414 --> 00:40:17,417 line:90%,end
<c.magenta>你可以通过空中处理机制解决</c>


786
00:40:17,484 --> 00:40:19,887 line:90%,end
<c.magenta>如果它们确实是你类型所必需的部分</c>


787
00:40:19,953 --> 00:40:21,922 line:90%,end
<c.magenta>或是将这些属性设为可选的</c>


788
00:40:22,656 --> 00:40:24,458 line:90%,end
<c.magenta>最后我们有数据侵蚀</c>


789
00:40:24,658 --> 00:40:26,360 line:90%,end
<c.magenta>数据侵蚀就是我们的捕捉所有错误</c>


790
00:40:26,426 --> 00:40:29,263 line:90%,end
<c.magenta>对于解码过程所能发生的</c>
<c.magenta>所有其他错误</c>


791
00:40:29,630 --> 00:40:31,164 line:90%,end
<c.magenta>为了看看它何处可能会有用</c>


792
00:40:31,231 --> 00:40:34,168 line:90%,end
<c.magenta>让我们深入看看解码时发生了什么</c>


793
00:40:34,635 --> 00:40:37,171 line:90%,end
<c.magenta>首先开始的时候</c>
<c.magenta>我们所拥有的都是字节码</c>


794
00:40:37,571 --> 00:40:39,072 line:90%,end
<c.magenta>它可能来自于网络</c>


795
00:40:39,139 --> 00:40:42,176 line:90%,end
<c.magenta>可能来自于磁盘上的某个文件</c>
<c.magenta>或是你应用里的某处</c>


796
00:40:42,242 --> 00:40:45,512 line:90%,end
<c.magenta>无论从哪来的 在此时</c>
<c.magenta>我们真的对于它们什么都不知道</c>


797
00:40:45,579 --> 00:40:49,283 line:90%,end
<c.magenta>因此第一步就是</c>
<c.magenta>将这些字节码转换成结构化的字节码</c>


798
00:40:50,450 --> 00:40:52,186 line:90%,end
<c.magenta>例如 这个JSON解码器</c>


799
00:40:52,252 --> 00:40:55,389 line:90%,end
<c.magenta>要验证JSON代码的</c>
<c.magenta>特定需求被满足</c>


800
00:40:55,722 --> 00:40:58,091 line:90%,end
<c.magenta>在压缩数据的开始 个别的字节码</c>


801
00:40:58,158 --> 00:40:59,626 line:90%,end
<c.magenta>表明了字符串编码</c>


802
00:40:59,893 --> 00:41:05,465 line:90%,end
<c.magenta>特定的用于字符串分隔符的</c>
<c.magenta>字符 数值 数组 词典等等</c>


803
00:41:05,866 --> 00:41:07,267 line:90%,end
<c.magenta>若其中任何东西看上去有错</c>


804
00:41:07,334 --> 00:41:11,104 line:90%,end
<c.magenta>JSON解码器就能抛出一个错误</c>
<c.magenta>并马上停止解码器的运行</c>


805
00:41:12,506 --> 00:41:16,176 line:90%,end
<c.magenta>在那之后 我们想要从</c>
<c.magenta>JSON数组 词典</c>


806
00:41:16,243 --> 00:41:19,179 line:90%,end
<c.magenta>以及字符串转换到你的类型</c>
<c.magenta>提交和编写者</c>


807
00:41:19,246 --> 00:41:21,849 line:90%,end
<c.magenta>毕竟这个API就是为此而生的</c>


808
00:41:22,716 --> 00:41:24,685 line:90%,end
<c.magenta>不过我们还可以做到更多</c>


809
00:41:25,385 --> 00:41:27,588 line:90%,end
<c.magenta>我们称之为域相关合法性验证</c>


810
00:41:27,988 --> 00:41:31,158 line:90%,end
<c.magenta>例如 你有个包含整型属性的类型</c>


811
00:41:31,225 --> 00:41:34,628 line:90%,end
<c.magenta>但是合法的整数只有0到100之间</c>


812
00:41:35,195 --> 00:41:38,131 line:90%,end
<c.magenta>或者你的类型有两种布尔属性</c>


813
00:41:38,198 --> 00:41:41,268 line:90%,end
<c.magenta>但是它们有着互斥的关系</c>


814
00:41:41,635 --> 00:41:45,138 line:90%,end
<c.magenta>这类事情很难通过Swift</c>
<c.magenta>的类型系统来表达</c>


815
00:41:45,205 --> 00:41:48,208 line:90%,end
<c.magenta>但是我们认为</c>
<c.magenta>我们有个很棒的工具来处理这些</c>


816
00:41:48,275 --> 00:41:50,277 line:90%,end
<c.magenta>而这仅需多写点Swift代码</c>
<c.magenta>就能实现</c>


817
00:41:50,344 --> 00:41:53,347 line:90%,end
<c.magenta>我们想要确保提供给你机会来实现</c>


818
00:41:53,413 --> 00:41:55,315 line:90%,end
<c.magenta>如果你有这类需求的话</c>


819
00:41:56,149 --> 00:41:58,385 line:10%
<c.magenta>最后你还有图形级别合法性验证</c>


820
00:41:58,619 --> 00:41:59,720 line:10%
<c.magenta>这是有关</c>


821
00:41:59,786 --> 00:42:03,056 line:90%,end
<c.magenta>图中的对象彼此间的关系</c>
<c.magenta>或是你应用的另一个部分</c>


822
00:42:04,424 --> 00:42:05,993 line:90%,end
<c.magenta>让我们将其应用到我们的提交中</c>


823
00:42:06,159 --> 00:42:09,296 line:90%,end
<c.magenta>此前我们看到了如何定制</c>
<c.magenta>commentCount属性</c>


824
00:42:09,363 --> 00:42:11,698 line:90%,end
<c.magenta>通过定制叫作</c>
<c.magenta>CodingKeys的枚举</c>


825
00:42:11,965 --> 00:42:14,067 line:90%,end
<c.magenta>现在我们将要定制可解码性</c>


826
00:42:14,134 --> 00:42:16,069 line:90%,end
<c.magenta>通过实现init from decoder</c>


827
00:42:16,870 --> 00:42:19,706 line:90%,end
<c.magenta>首先 我为解码器请求一个容器</c>


828
00:42:20,207 --> 00:42:22,876 line:90%,end
<c.magenta>容器就是用来匹配你的键</c>


829
00:42:22,943 --> 00:42:25,712 line:90%,end
<c.magenta>到你期望在压缩数据中所找到的值</c>


830
00:42:26,813 --> 00:42:30,517 line:90%,end
<c.magenta>一旦我们有了一个容器</c>
<c.magenta>我们就可以向它请求我们所需要的值</c>


831
00:42:30,617 --> 00:42:34,087 line:90%,end
<c.magenta>在这里 是一个URL</c>
<c.magenta>一个字符串 编写者</c>


832
00:42:34,154 --> 00:42:38,625 line:90%,end
<c.magenta>还有我们的递归降序</c>
<c.magenta>以及commentCount的整型数值</c>


833
00:42:39,626 --> 00:42:41,428 line:90%,end
<c.magenta>比如说现在我有一个额外需求</c>


834
00:42:41,495 --> 00:42:43,764 line:90%,end
<c.magenta>就是我需要作为技术规格</c>
<c.magenta>的一部分进行验证</c>


835
00:42:43,830 --> 00:42:47,067 line:90%,end
<c.magenta>所有的URL都必须是HTTPS</c>


836
00:42:47,467 --> 00:42:49,636 line:90%,end
<c.magenta>如果它们不是的话 就会有错误</c>


837
00:42:50,003 --> 00:42:53,574 line:10%
<c.magenta>让我们看看如果实现吧</c>
<c.magenta>首先 在幻灯片上腾出更多空间</c>


838
00:42:54,208 --> 00:42:57,711 line:10%
<c.magenta>然后 我会使用我们</c>
<c.magenta>已经知道怎么用的URL API</c>


839
00:42:57,778 --> 00:42:59,713 line:10%
<c.magenta>那就是scheme属性</c>


840
00:43:00,614 --> 00:43:03,817 line:10%
<c.magenta>这里我只检查是否等于HTTPS</c>
<c.magenta>如果它不相等</c>


841
00:43:03,951 --> 00:43:05,886 line:10%
<c.magenta>我就可以抛出一个解码错误</c>


842
00:43:05,953 --> 00:43:08,689 line:10%
<c.magenta>提供一个排除故障描述</c>
<c.magenta>以便你可在调试器里捕捉到它</c>


843
00:43:08,755 --> 00:43:10,357 line:10%
<c.magenta>就如同毅太在演示中所展示的那样</c>


844
00:43:10,657 --> 00:43:14,995 line:10%
<c.magenta>你没注意到的是 这个类型 提交</c>


845
00:43:15,062 --> 00:43:17,064 line:10%
<c.magenta>检查了URL的字符串值</c>


846
00:43:17,698 --> 00:43:19,633 line:10%
<c.magenta>我们可以允许URL解码自己</c>


847
00:43:20,167 --> 00:43:23,036 line:90%,end
<c.magenta>这也是这个设计如此之棒的部分原因</c>


848
00:43:23,337 --> 00:43:26,006 line:90%,end
<c.magenta>URL知道某个字符串是不是URL</c>


849
00:43:26,073 --> 00:43:29,109 line:90%,end
<c.magenta>如果不是的话 它就会抛出一个错误</c>
<c.magenta>甚至在我们到这步之前</c>


850
00:43:29,409 --> 00:43:31,612 line:90%,end
<c.magenta>由于Swift错误处理的设计</c>


851
00:43:31,678 --> 00:43:35,082 line:90%,end
<c.magenta>可以延迟这个类型到解码提交</c>


852
00:43:35,148 --> 00:43:36,416 line:90%,end
<c.magenta>或者甚至更高层级</c>


853
00:43:38,719 --> 00:43:40,521 line:90%,end
<c.magenta>让我们接着看第二个支柱</c>


854
00:43:40,587 --> 00:43:43,257 line:90%,end
<c.magenta>那就是编码细节的封装</c>


855
00:43:44,358 --> 00:43:48,128 line:90%,end
<c.magenta>我们觉得保证键和值非常重要</c>


856
00:43:48,195 --> 00:43:51,665 line:90%,end
<c.magenta>它们是一个类型选择私密的东西</c>
<c.magenta>放到压缩数据</c>


857
00:43:52,366 --> 00:43:53,734 line:90%,end
<c.magenta>原因很重要</c>


858
00:43:53,800 --> 00:43:56,470 line:90%,end
<c.magenta>因为这减少了我们的工作量</c>


859
00:43:56,537 --> 00:43:58,839 line:90%,end
<c.magenta>设计某些带有全局知识的</c>


860
00:43:58,906 --> 00:44:01,475 line:90%,end
<c.magenta>在压缩数据里可能会出现的东西</c>


861
00:44:02,109 --> 00:44:04,878 line:90%,end
<c.magenta>我们实现这种封装的主要机制</c>


862
00:44:04,945 --> 00:44:07,581 line:90%,end
<c.magenta>叫作容器 我们有三种</c>


863
00:44:08,115 --> 00:44:10,017 line:90%,end
<c.magenta>第一种叫作加密容器</c>


864
00:44:10,684 --> 00:44:14,021 line:90%,end
<c.magenta>加密容器是大多数情况下的优先选择</c>


865
00:44:14,188 --> 00:44:18,358 line:90%,end
<c.magenta>原因是因为</c>
<c.magenta>它们目前是向前向后最兼容的</c>


866
00:44:18,759 --> 00:44:22,196 line:90%,end
<c.magenta>如果你新版本的应用里</c>
<c.magenta>有新的或者变动的数据</c>


867
00:44:22,429 --> 00:44:23,897 line:90%,end
<c.magenta>你只需要用一个新的密钥</c>


868
00:44:24,498 --> 00:44:26,667 line:90%,end
<c.magenta>这使得应用的绝大多数版本</c>


869
00:44:26,733 --> 00:44:28,769 line:90%,end
<c.magenta>与你数据的绝大多数版本相兼容</c>


870
00:44:28,836 --> 00:44:31,104 line:90%,end
<c.magenta>这对于每个人都是最好的可能结果</c>


871
00:44:32,039 --> 00:44:34,041 line:90%,end
<c.magenta>让我们看看这些密钥实际上是什么</c>


872
00:44:34,107 --> 00:44:36,076 line:90%,end
<c.magenta>早些时候</c>
<c.magenta>我们谈了CodingKey协议</c>


873
00:44:36,143 --> 00:44:37,144 line:90%,end
<c.magenta>就是这个</c>


874
00:44:37,444 --> 00:44:41,248 line:90%,end
<c.magenta>它有两个协议</c>
<c.magenta>或者两个属性和两个初始化</c>


875
00:44:41,748 --> 00:44:43,517 line:90%,end
<c.magenta>属性就是stringValue</c>


876
00:44:43,584 --> 00:44:45,986 line:90%,end
<c.magenta>例如 你在用JSON时候就很方便</c>


877
00:44:46,053 --> 00:44:48,956 line:90%,end
<c.magenta>不过你也可以提供一个整型数值</c>
<c.magenta>这对于格式很有用</c>


878
00:44:49,022 --> 00:44:51,992 line:90%,end
<c.magenta>这或许提供了一个</c>
<c.magenta>更有效的编码二进制表现</c>


879
00:44:53,060 --> 00:44:56,396 line:90%,end
<c.magenta>而初始化</c>
<c.magenta>我想让你们注意的是它们是可选的</c>


880
00:44:56,463 --> 00:44:57,798 line:90%,end
<c.magenta>这就意味着解码器</c>


881
00:44:57,865 --> 00:45:01,235 line:90%,end
<c.magenta>拥有执行额外一层安全性检查的能力</c>


882
00:45:01,368 --> 00:45:03,871 line:90%,end
<c.magenta>它可以验证你的代码密钥</c>


883
00:45:03,937 --> 00:45:07,808 line:90%,end
<c.magenta>你在压缩数据中所找到的值</c>
<c.magenta>就是你想要的</c>


884
00:45:08,275 --> 00:45:11,345 line:90%,end
<c.magenta>通常你要在枚举上采用这个协议</c>


885
00:45:11,411 --> 00:45:12,946 line:90%,end
<c.magenta>就如同我们目前看到的这个</c>


886
00:45:13,280 --> 00:45:15,048 line:90%,end
<c.magenta>这里所发生的就是</c>


887
00:45:15,115 --> 00:45:16,583 line:90%,end
<c.magenta>标准库的编译器</c>


888
00:45:16,650 --> 00:45:19,086 line:90%,end
<c.magenta>提供一个所有这四种需求的实现</c>


889
00:45:19,152 --> 00:45:20,420 line:90%,end
<c.magenta>完全免费给我们</c>


890
00:45:20,888 --> 00:45:23,957 line:10%
<c.magenta>在这里 因为枚举是由字符串组成的</c>


891
00:45:24,458 --> 00:45:27,027 line:10%
<c.magenta>编译器使用case名</c>
<c.magenta>作为字符串的值</c>


892
00:45:27,094 --> 00:45:29,329 line:10%
<c.magenta>同时为了属性还有初始化</c>


893
00:45:29,696 --> 00:45:31,231 line:10%
<c.magenta>不过intValue还是nil</c>


894
00:45:31,298 --> 00:45:33,033 line:10%
<c.magenta>因为在这个枚举中没有足够的信息</c>


895
00:45:33,100 --> 00:45:35,102 line:10%
<c.magenta>来给它分配一个特定值</c>


896
00:45:36,003 --> 00:45:39,406 line:10%
<c.magenta>早前当我们定制case名的时候</c>
<c.magenta>你现在可以看到这是如何运作的</c>


897
00:45:39,473 --> 00:45:42,509 line:10%
<c.magenta>我们改变了case的名字</c>
<c.magenta>但是值仍然是一样的</c>


898
00:45:42,576 --> 00:45:45,812 line:10%
<c.magenta>因此stringValue仍和</c>
<c.magenta>GitHub API保持兼容</c>


899
00:45:47,147 --> 00:45:48,582 line:10%
<c.magenta>如果你在写库的代码</c>


900
00:45:48,649 --> 00:45:52,119 line:10%
<c.magenta>我会鼓励你考虑用整型</c>
<c.magenta>来写你的CodingKeys</c>


901
00:45:52,186 --> 00:45:56,323 line:10%
<c.magenta>如果你这么做</c>
<c.magenta>你仍会从编译器获得更多免费实现</c>


902
00:45:56,390 --> 00:46:00,060 line:10%
<c.magenta>在这个例子中</c>
<c.magenta>一个整型数值 这会对格式很有用</c>


903
00:46:00,127 --> 00:46:01,728 line:10%
<c.magenta>其可能支持整型密钥</c>


904
00:46:03,697 --> 00:46:08,569 line:90%,end
<c.magenta>我们也支持未加密容器</c>
<c.magenta>这些依次编码和解码</c>


905
00:46:09,236 --> 00:46:12,806 line:90%,end
<c.magenta>对于有序或无边界的数据</c>
<c.magenta>使用这些容器 其原因就是</c>


906
00:46:12,873 --> 00:46:14,541 line:90%,end
<c.magenta>你不需要生成假的密钥</c>


907
00:46:14,608 --> 00:46:16,543 line:90%,end
<c.magenta>让你的数据进入压缩数据</c>


908
00:46:16,977 --> 00:46:19,213 line:90%,end
<c.magenta>我们也支持单一值容器</c>


909
00:46:19,279 --> 00:46:22,349 line:90%,end
<c.magenta>就如这个名字所指的</c>
<c.magenta>只保存一个项目</c>


910
00:46:22,883 --> 00:46:24,251 line:90%,end
<c.magenta>对于主类型使用这些容器</c>


911
00:46:24,318 --> 00:46:26,253 line:90%,end
<c.magenta>例如 以秒数保存的日期</c>


912
00:46:26,553 --> 00:46:28,155 line:90%,end
<c.magenta>由于是时间内的一个引用点</c>


913
00:46:28,889 --> 00:46:30,691 line:90%,end
<c.magenta>当你在其中选择的时候 你应该注意</c>


914
00:46:30,757 --> 00:46:34,728 line:90%,end
<c.magenta>这些是最不兼容的选择 一定要记住</c>


915
00:46:35,796 --> 00:46:37,898 line:90%,end
<c.magenta>让我们再一次回到我们的提交</c>


916
00:46:39,066 --> 00:46:41,335 line:90%,end
<c.magenta>我们可以看到</c>
<c.magenta>如何定制了commentCount</c>


917
00:46:41,401 --> 00:46:43,237 line:90%,end
<c.magenta>还有它的CodingKeys</c>


918
00:46:43,303 --> 00:46:45,539 line:90%,end
<c.magenta>通过改变init</c>
<c.magenta>from decoder来解码</c>


919
00:46:45,806 --> 00:46:49,476 line:90%,end
<c.magenta>现在让我们看看</c>
<c.magenta>encode to encoder的编码</c>


920
00:46:49,776 --> 00:46:52,145 line:90%,end
<c.magenta>实际上 我在这不需要定制任何东西</c>


921
00:46:52,212 --> 00:46:53,814 line:90%,end
<c.magenta>不过我仍然想给你们展示看看</c>
<c.magenta>它是什么样的</c>


922
00:46:53,881 --> 00:46:55,582 line:90%,end
<c.magenta>以便你们能理解它是如何运作的</c>


923
00:46:55,649 --> 00:46:59,586 line:90%,end
<c.magenta>首先 我们有一个容器</c>
<c.magenta>并且这个容器如你所见</c>


924
00:46:59,653 --> 00:47:02,756 line:90%,end
<c.magenta>藉由我们自己的私密</c>
<c.magenta>CodingKeys所编码</c>


925
00:47:03,290 --> 00:47:06,193 line:90%,end
<c.magenta>这个容器就是我如何编码</c>


926
00:47:06,260 --> 00:47:08,562 line:90%,end
<c.magenta>我想要放入压缩数据的值</c>


927
00:47:08,629 --> 00:47:11,498 line:90%,end
<c.magenta>我们的URL信息 编写者</c>
<c.magenta>递归降序</c>


928
00:47:11,565 --> 00:47:12,666 line:90%,end
<c.magenta>还有commentCount</c>


929
00:47:13,500 --> 00:47:16,436 line:90%,end
<c.magenta>我想给你们展示一个如何选择的例子</c>
<c.magenta>选择不同种类的容器</c>


930
00:47:16,503 --> 00:47:18,805 line:90%,end
<c.magenta>比如说我们正在处理</c>
<c.magenta>GO JSON代码</c>


931
00:47:18,872 --> 00:47:20,874 line:90%,end
<c.magenta>其有一个点的概念</c>


932
00:47:21,275 --> 00:47:24,945 line:90%,end
<c.magenta>点有两个值 它应该在JSON中</c>
<c.magenta>是两个数值型元素的数组</c>


933
00:47:25,012 --> 00:47:28,315 line:90%,end
<c.magenta>为了使其能正常运作</c>
<c.magenta>我会采用可编码性</c>


934
00:47:28,382 --> 00:47:32,186 line:90%,end
<c.magenta>并且使用一个未加密容器</c>
<c.magenta>来实现encode to encoder</c>


935
00:47:32,252 --> 00:47:35,622 line:90%,end
<c.magenta>你会注意到这个容器中没有密钥</c>


936
00:47:35,689 --> 00:47:37,591 line:90%,end
<c.magenta>当我编码的时候 我没有用密钥</c>


937
00:47:37,658 --> 00:47:40,494 line:90%,end
<c.magenta>JSON中的结果就像是这样</c>


938
00:47:41,728 --> 00:47:43,630 line:90%,end
<c.magenta>我们也支持嵌套式的容器</c>


939
00:47:44,398 --> 00:47:46,900 line:90%,end
<c.magenta>比如说我的词典中的第二个项目</c>


940
00:47:46,967 --> 00:47:48,936 line:90%,end
<c.magenta>需要包含三个值的一个数组</c>


941
00:47:49,002 --> 00:47:53,207 line:90%,end
<c.magenta>因此 如你所见 我们支持嵌套</c>
<c.magenta>未加密容器和加密容器</c>


942
00:47:53,273 --> 00:47:56,276 line:90%,end
<c.magenta>或者其他任何加密</c>
<c.magenta>未加密和单一值的组合</c>


943
00:47:56,977 --> 00:48:00,080 line:90%,end
<c.magenta>嵌套式容器的主要用例就是类</c>


944
00:48:00,414 --> 00:48:03,250 line:90%,end
<c.magenta>到目前为止</c>
<c.magenta>我们谈了很多关于结构体的问题</c>


945
00:48:03,317 --> 00:48:06,220 line:90%,end
<c.magenta>但嵌套式容器给了我们一个自然机制</c>


946
00:48:06,286 --> 00:48:09,890 line:90%,end
<c.magenta>从我们作为子类的自己数据</c>
<c.magenta>用来封装超类数据</c>


947
00:48:09,957 --> 00:48:11,592 line:90%,end
<c.magenta>也就是一个来自于NSCoding的变化</c>


948
00:48:12,092 --> 00:48:13,126 line:90%,end
<c.magenta>我们来看一个例子</c>


949
00:48:13,360 --> 00:48:16,263 line:90%,end
<c.magenta>就是每个人都喜欢的</c>
<c.magenta>面向对象的例子 动物</c>


950
00:48:16,330 --> 00:48:18,799 line:90%,end
<c.magenta>很自然 动物有个legCount</c>


951
00:48:19,566 --> 00:48:21,235 line:90%,end
<c.magenta>还有它自己的CodingKeys</c>


952
00:48:21,301 --> 00:48:25,005 line:90%,end
<c.magenta>并且你看到在这个类中</c>
<c.magenta>当我实现init from decoder时</c>


953
00:48:25,072 --> 00:48:26,473 line:90%,end
<c.magenta>它是一个必需的初始化</c>


954
00:48:27,674 --> 00:48:29,176 line:90%,end
<c.magenta>这里我创建了一个加密容器</c>


955
00:48:29,243 --> 00:48:31,812 line:90%,end
<c.magenta>使用动物的CodingKeys</c>
<c.magenta>并且解码我的腿计数</c>


956
00:48:31,979 --> 00:48:33,780 line:90%,end
<c.magenta>跟我们目前为止所见过的很类似</c>


957
00:48:34,481 --> 00:48:35,782 line:90%,end
<c.magenta>让我们创建一个它的子类</c>


958
00:48:36,450 --> 00:48:38,585 line:90%,end
<c.magenta>狗是有最好朋友的一种动物</c>


959
00:48:38,652 --> 00:48:40,888 line:90%,end
<c.magenta>也就是我们早前生日派对里的小孩</c>


960
00:48:41,154 --> 00:48:45,192 line:90%,end
<c.magenta>你会注意到dog也有个叫作</c>
<c.magenta>CodingKeys的私有枚举</c>


961
00:48:45,259 --> 00:48:48,529 line:90%,end
<c.magenta>即使它有着与超类中相同的名字</c>


962
00:48:48,595 --> 00:48:52,900 line:90%,end
<c.magenta>因为它是私有的</c>
<c.magenta>它并不会与动物所使用的相冲突</c>


963
00:48:53,333 --> 00:48:55,836 line:90%,end
<c.magenta>因此 当我实现dog的</c>
<c.magenta>init from decoder时</c>


964
00:48:55,903 --> 00:48:58,672 line:90%,end
<c.magenta>并且使用它自己的CodingKeys</c>
<c.magenta>来获得一个容器</c>


965
00:48:58,739 --> 00:49:02,643 line:90%,end
<c.magenta>我可以利用对于它来说重要的密钥</c>
<c.magenta>以一种类型安全的方式解码</c>


966
00:49:02,709 --> 00:49:03,777 line:90%,end
<c.magenta>而不是对它的超类重要</c>


967
00:49:04,444 --> 00:49:06,213 line:90%,end
<c.magenta>现在 我们需要完成那个嵌套</c>


968
00:49:06,446 --> 00:49:08,248 line:90%,end
<c.magenta>我们可以调用超类</c>


969
00:49:08,315 --> 00:49:11,552 line:90%,end
<c.magenta>利用我们接收到的解码器</c>
<c.magenta>来实现超类的init from decoder</c>


970
00:49:11,919 --> 00:49:17,157 line:90%,end
<c.magenta>然而 这不会给容器机会</c>
<c.magenta>来嵌套该超类数据</c>


971
00:49:17,624 --> 00:49:20,894 line:10%
<c.magenta>因此 最简单的实现方法</c>
<c.magenta>就是使用这个方便的API</c>


972
00:49:20,961 --> 00:49:22,095 line:10%
<c.magenta>叫作superDecoder</c>


973
00:49:22,162 --> 00:49:25,098 line:10%
<c.magenta>它会获得一个新的</c>
<c.magenta>可以传到我们超类的解码器</c>


974
00:49:25,332 --> 00:49:30,537 line:10%
<c.magenta>通过调用super 我们满足了</c>
<c.magenta>Swift的规则来创建一个初始化</c>


975
00:49:30,604 --> 00:49:33,874 line:10%
<c.magenta>其实现了一个随时可用的</c>
<c.magenta>最终初始化了的类型</c>


976
00:49:36,910 --> 00:49:38,445 line:90%,end
<c.magenta>最后是我们的第三个支柱</c>


977
00:49:38,512 --> 00:49:42,382 line:90%,end
<c.magenta>那就是从这些类型中抽象出编码格式</c>


978
00:49:43,483 --> 00:49:45,452 line:90%,end
<c.magenta>我们觉得能够重用很重要</c>


979
00:49:45,519 --> 00:49:48,288 line:90%,end
<c.magenta>就是重用这些协议的实现</c>


980
00:49:49,022 --> 00:49:50,724 line:90%,end
<c.magenta>我们不想以这种局面结束</c>


981
00:49:50,791 --> 00:49:53,694 line:90%,end
<c.magenta>就是我们有很多几乎相同的实现</c>


982
00:49:53,760 --> 00:49:57,231 line:90%,end
<c.magenta>对于可编码性和可解码性</c>
<c.magenta>来支持新的格式</c>


983
00:49:57,865 --> 00:50:00,334 line:90%,end
<c.magenta>因此通过抽象格式</c>


984
00:50:00,400 --> 00:50:03,403 line:90%,end
<c.magenta>我们可以不改变任何库</c>
<c.magenta>就可以允许全新的格式</c>


985
00:50:03,537 --> 00:50:07,508 line:90%,end
<c.magenta>这些格式可以来自于我们或你们</c>
<c.magenta>甚至来自于Swift包</c>


986
00:50:07,574 --> 00:50:10,010 line:90%,end
<c.magenta>这些格式可以与这些类型一起运作</c>


987
00:50:10,077 --> 00:50:12,880 line:90%,end
<c.magenta>来自于我们的 来自于你们的</c>
<c.magenta>或者来自Swift包的</c>


988
00:50:13,714 --> 00:50:16,083 line:90%,end
<c.magenta>不过我们也理解 不同的格式</c>


989
00:50:16,149 --> 00:50:19,286 line:90%,end
<c.magenta>有着不同的基础类型和不同的规范</c>


990
00:50:19,820 --> 00:50:21,588 line:90%,end
<c.magenta>因为我们保证运作正常的机制</c>


991
00:50:21,655 --> 00:50:23,123 line:90%,end
<c.magenta>叫作编码战略</c>


992
00:50:23,624 --> 00:50:27,761 line:90%,end
<c.magenta>这是针对特定类型的</c>
<c.magenta>基于编码器和解码器的定制</c>


993
00:50:28,061 --> 00:50:30,564 line:90%,end
<c.magenta>例如 在JSON中</c>
<c.magenta>我们已经看到了关于日期的内容</c>


994
00:50:30,931 --> 00:50:34,935 line:90%,end
<c.magenta>在我们的GitHub例子中</c>
<c.magenta>日期被编码为ISO8601字符串</c>


995
00:50:35,402 --> 00:50:38,105 line:90%,end
<c.magenta>不过还有其他可能的规范</c>


996
00:50:38,172 --> 00:50:40,841 line:90%,end
<c.magenta>例如 作为引用日期的秒数</c>


997
00:50:40,908 --> 00:50:43,076 line:90%,end
<c.magenta>作为引用日期的毫秒数</c>


998
00:50:43,143 --> 00:50:45,746 line:90%,end
<c.magenta>或者你甚至可以声明</c>
<c.magenta>一个完全定制的日期格式器</c>


999
00:50:45,812 --> 00:50:48,015 line:90%,end
<c.magenta>如果你脑子里有些很专注的东西</c>


1000
00:50:48,916 --> 00:50:51,785 line:90%,end
<c.magenta>JSON编码器和解码器</c>
<c.magenta>支持其他种类的战略</c>


1001
00:50:51,852 --> 00:50:53,654 line:90%,end
<c.magenta>例如 对于数据</c>


1002
00:50:53,854 --> 00:50:56,990 line:10%
<c.magenta>在JSON中 用Base64</c>
<c.magenta>编码数据是很常见的</c>


1003
00:50:57,824 --> 00:51:01,061 line:10%
<c.magenta>不过我们也允许你通过选择战略</c>
<c.magenta>来定制这个</c>


1004
00:51:01,128 --> 00:51:03,564 line:10%
<c.magenta>也就是作为字节码的数组来编码它</c>


1005
00:51:03,630 --> 00:51:06,200 line:10%
<c.magenta>或者你可以声明某些完全定制的东西</c>
<c.magenta>像是这个</c>


1006
00:51:06,266 --> 00:51:09,136 line:10%
<c.magenta>把所有的零变成绵羊</c>
<c.magenta>把所有其他的变成狗</c>


1007
00:51:09,403 --> 00:51:13,373 line:10%
<c.magenta>我不知道你为什么要这么做</c>
<c.magenta>但是这是可能的 就是这样</c>


1008
00:51:13,907 --> 00:51:17,377 line:10%
<c.magenta>抽象也可以帮助我们利用不同的格式</c>


1009
00:51:17,444 --> 00:51:19,479 line:10%
<c.magenta>如我们所见 今天谈论了</c>
<c.magenta>很多关于JSON的东西</c>


1010
00:51:19,546 --> 00:51:23,016 line:10%
<c.magenta>但实际上 我们也引入了</c>
<c.magenta>属性表的编码器和解码器</c>


1011
00:51:23,283 --> 00:51:27,721 line:10%
<c.magenta>而属性表 不像是JSON</c>
<c.magenta>有对于数据和日期的原生类型</c>


1012
00:51:27,821 --> 00:51:29,756 line:10%
<c.magenta>因此当这些编码器和解码器</c>


1013
00:51:30,090 --> 00:51:32,860 line:10%
<c.magenta>遇到这些对象</c>
<c.magenta>无论它正在编码的对象图里</c>


1014
00:51:32,926 --> 00:51:34,995 line:10%
<c.magenta>还是在解压缩的数据里</c>


1015
00:51:35,329 --> 00:51:38,565 line:10%
<c.magenta>我们都可以将它们转换成</c>
<c.magenta>对于该格式恰当正确的类型</c>


1016
00:51:39,733 --> 00:51:42,503 line:10%
<c.magenta>由于这些抽象</c>
<c.magenta>我们可以采用可编码性协议</c>


1017
00:51:42,569 --> 00:51:45,939 line:10%
<c.magenta>在许多Foundation类型中</c>
<c.magenta>包括所有你们在这看到的</c>


1018
00:51:47,708 --> 00:51:49,543 line:10%
<c.magenta>我们已经谈论了许多关于</c>
<c.magenta>可编码性API的内容</c>


1019
00:51:49,610 --> 00:51:51,845 line:10%
<c.magenta>我想要给你们一个清晰的概括</c>


1020
00:51:51,912 --> 00:51:54,047 line:10%
<c.magenta>来帮助你们理解全局</c>


1021
00:51:54,114 --> 00:51:56,450 line:90%,end
<c.magenta>当然了 我们从你的类型开始</c>


1022
00:51:56,517 --> 00:52:00,754 line:90%,end
<c.magenta>你的类型采用两种协议</c>
<c.magenta>他们叫作可编码性和可解码性</c>


1023
00:52:01,822 --> 00:52:03,924 line:90%,end
<c.magenta>它们有一个函数和一个初始化</c>


1024
00:52:03,991 --> 00:52:07,160 line:90%,end
<c.magenta>其让你访问编码器和解码器</c>


1025
00:52:08,161 --> 00:52:10,163 line:90%,end
<c.magenta>这些可供你访问容器</c>


1026
00:52:10,230 --> 00:52:13,133 line:90%,end
<c.magenta>那也是在压缩数据中</c>
<c.magenta>实际保存值的地方</c>


1027
00:52:13,200 --> 00:52:14,868 line:90%,end
<c.magenta>在加密容器的情况下</c>


1028
00:52:14,935 --> 00:52:18,005 line:90%,end
<c.magenta>我们使用由你的类型</c>
<c.magenta>所定义的CodingKeys</c>


1029
00:52:19,106 --> 00:52:21,475 line:90%,end
<c.magenta>最后 就是编码器和容器</c>


1030
00:52:21,542 --> 00:52:26,079 line:90%,end
<c.magenta>提供了对于编码格式的抽象</c>
<c.magenta>像是JSON 属性表等等</c>


1031
00:52:28,148 --> 00:52:31,351 line:90%,end
<c.magenta>我们今天开始时候</c>
<c.magenta>介绍了一些新的API</c>


1032
00:52:31,418 --> 00:52:34,321 line:90%,end
<c.magenta>还有今年新发布的</c>
<c.magenta>Foundation所改进的性能表现</c>


1033
00:52:34,388 --> 00:52:37,691 line:90%,end
<c.magenta>在那之后</c>
<c.magenta>我们看了Swift新的强类型键径</c>


1034
00:52:37,758 --> 00:52:42,596 line:90%,end
<c.magenta>包括一个非常酷的用例 就是全新的</c>
<c.magenta>基于终结的KVO API</c>


1035
00:52:43,063 --> 00:52:45,766 line:90%,end
<c.magenta>最后 我们介绍新的可编码性协议</c>


1036
00:52:45,832 --> 00:52:48,836 line:90%,end
<c.magenta>其使得与其他格式的集成非常简单</c>
<c.magenta>像是JSON</c>


1037
00:52:48,902 --> 00:52:52,306 line:90%,end
<c.magenta>而且也允许你进行强大的定制</c>


1038
00:52:53,607 --> 00:52:55,542 line:90%,end
<c.magenta>有关更多信息 请查阅这个链接</c>


1039
00:52:56,009 --> 00:52:58,879 line:90%,end
<c.magenta>我们有一些与所谈内容相关的演讲</c>


1040
00:53:00,514 --> 00:53:01,448 line:90%,end
<c.magenta>非常感谢</c>

