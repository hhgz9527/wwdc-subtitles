1
00:00:16,917 --> 00:00:21,522 line:10%
<c.magenta>（应用启动时间：</c>
<c.magenta>过去、现在和未来）</c>


2
00:00:21,588 --> 00:00:22,723 line:10%
<c.magenta>大家好</c>


3
00:00:26,994 --> 00:00:28,629 line:90%,end
<c.magenta>欢迎参加演讲</c>


4
00:00:28,996 --> 00:00:31,598 line:90%,end
<c.magenta>我是Louis Gerbarg</c>
<c.magenta>是dyld团队成员</c>


5
00:00:31,798 --> 00:00:35,302 line:90%,end
<c.magenta>今天我们将会讨论</c>
<c.magenta>应用启动的过去、现在和未来</c>


6
00:00:36,436 --> 00:00:39,239 line:90%,end
<c.magenta>今天的内容很多</c>
<c.magenta>让我们开始吧</c>


7
00:00:39,806 --> 00:00:40,974 line:90%,end
<c.magenta>我想概要介绍</c>


8
00:00:41,041 --> 00:00:43,110 line:90%,end
<c.magenta>今天要讲的内容</c>


9
00:00:43,410 --> 00:00:48,682 line:90%,end
<c.magenta>首先我会回顾</c>
<c.magenta>去年我们给出的一些建议</c>


10
00:00:49,216 --> 00:00:51,852 line:90%,end
<c.magenta>然后讨论我们开发的一些新工具</c>


11
00:00:51,919 --> 00:00:56,156 line:90%,end
<c.magenta>这些工具可以更方便地</c>
<c.magenta>找到特定类型的程序启动时间问题</c>


12
00:00:56,757 --> 00:00:59,593 line:90%,end
<c.magenta>然后 我简要介绍</c>
<c.magenta>dyld在我们平台上的</c>


13
00:00:59,660 --> 00:01:01,962 line:90%,end
<c.magenta>应用历史</c>


14
00:01:02,529 --> 00:01:06,667 line:90%,end
<c.magenta>接下来我想讨论我们将在</c>
<c.magenta>macOS High Sierra和iOS 11中</c>


15
00:01:06,733 --> 00:01:10,137 line:90%,end
<c.magenta>发布的全新dyld</c>


16
00:01:10,671 --> 00:01:14,641 line:90%,end
<c.magenta>最后我想讨论</c>
<c.magenta>这个全新dyld的最佳实践</c>


17
00:01:16,109 --> 00:01:20,414 line:90%,end
<c.magenta>首先我做一下记录</c>


18
00:01:21,882 --> 00:01:23,917 line:90%,end
<c.magenta>我们希望倾听你们的意见</c>


19
00:01:24,218 --> 00:01:28,488 line:90%,end
<c.magenta>如果你们遇到什么问题</c>
<c.magenta>可以将这些问题告诉我们</c>


20
00:01:28,555 --> 00:01:31,992 line:90%,end
<c.magenta>请将标题设为“DYLD USAGE”</c>
<c.magenta>我们将会解答这些问题</c>


21
00:01:34,428 --> 00:01:36,363 line:90%,end
<c.magenta>现在我想介绍</c>
<c.magenta>我们将会在本演讲中</c>


22
00:01:36,430 --> 00:01:37,598 line:90%,end
<c.magenta>使用的一些术语</c>


23
00:01:38,999 --> 00:01:42,769 line:90%,end
<c.magenta>首先 启动时间是什么意思？</c>


24
00:01:43,704 --> 00:01:46,874 line:90%,end
<c.magenta>在本演讲中</c>
<c.magenta>启动时间是指</c>


25
00:01:46,940 --> 00:01:49,443 line:90%,end
<c.magenta>main函数执行之前所用的时间</c>


26
00:01:49,743 --> 00:01:53,447 line:90%,end
<c.magenta>如果你编写一个应用</c>
<c.magenta>你需要做很多的事情</c>


27
00:01:53,514 --> 00:01:57,017 line:90%,end
<c.magenta>完成之后</c>
<c.magenta>需要加载nib文件和执行其它操作</c>


28
00:01:57,084 --> 00:01:59,419 line:90%,end
<c.magenta>需要运行</c>


29
00:02:00,387 --> 00:02:02,656 line:90%,end
<c.magenta>UI Application Delegates代码</c>


30
00:02:03,357 --> 00:02:07,194 line:90%,end
<c.magenta>这方面的知识有很多</c>
<c.magenta>很多演讲都曾经进行过讨论</c>


31
00:02:07,494 --> 00:02:10,130 line:90%,end
<c.magenta>今天我们讨论main执行之前</c>
<c.magenta>所发生的事情</c>


32
00:02:10,197 --> 00:02:11,899 line:90%,end
<c.magenta>以及你可以如何加速这个过程</c>


33
00:02:12,666 --> 00:02:17,571 line:90%,end
<c.magenta>此外 我还想要解释</c>
<c.magenta>启动收尾 这是一个新术语</c>


34
00:02:18,505 --> 00:02:21,975 line:10%
<c.magenta>启动收尾是指启动你的程序</c>


35
00:02:22,042 --> 00:02:23,343 line:10%
<c.magenta>所需要的全部信息</c>


36
00:02:23,577 --> 00:02:27,714 line:10%
<c.magenta>比如使用什么dylib</c>
<c.magenta>它们的哪些偏移位置用于不同的符号</c>


37
00:02:27,781 --> 00:02:29,550 line:10%
<c.magenta>代码签名是什么</c>


38
00:02:31,118 --> 00:02:34,721 line:90%,end
<c.magenta>让我们进入演讲的主题</c>


39
00:02:35,589 --> 00:02:39,226 line:90%,end
<c.magenta>去年我说过</c>


40
00:02:39,293 --> 00:02:42,062 line:90%,end
<c.magenta>我们应该减少代码</c>
<c.magenta>我仍然会强调这一点</c>


41
00:02:42,129 --> 00:02:45,532 line:90%,end
<c.magenta>因为代码越少 启动就越快</c>


42
00:02:45,799 --> 00:02:49,403 line:90%,end
<c.magenta>无论我们如何加速</c>
<c.magenta>代码越少</c>


43
00:02:49,469 --> 00:02:50,737 line:90%,end
<c.magenta>启动速度就越快</c>


44
00:02:51,672 --> 00:02:53,874 line:90%,end
<c.magenta>这个建议始终适用</c>


45
00:02:54,608 --> 00:02:59,713 line:90%,end
<c.magenta>你应该使用更少的dylib</c>
<c.magenta>减少嵌入的dylib</c>


46
00:02:59,780 --> 00:03:02,249 line:90%,end
<c.magenta>从时间的角度来看</c>


47
00:03:02,583 --> 00:03:04,685 line:90%,end
<c.magenta>使用系统库效果更好</c>
<c.magenta>我们将会探讨这一点</c>


48
00:03:05,419 --> 00:03:08,388 line:90%,end
<c.magenta>应该声明较少的库和方法</c>


49
00:03:08,455 --> 00:03:11,558 line:90%,end
<c.magenta>减少初始化函数</c>


50
00:03:13,627 --> 00:03:16,396 line:90%,end
<c.magenta>最后我将会介绍一些事半功倍的方法</c>


51
00:03:16,463 --> 00:03:19,533 line:90%,end
<c.magenta>你可以使用更多的Swift代码</c>


52
00:03:19,600 --> 00:03:24,204 line:90%,end
<c.magenta>因为Swift从设计上</c>
<c.magenta>避免许多的陷阱</c>


53
00:03:24,271 --> 00:03:27,341 line:90%,end
<c.magenta>在使用C、C++ 和</c>
<c.magenta>Objective-C可能会遇到这些陷阱</c>


54
00:03:27,407 --> 00:03:29,443 line:90%,end
<c.magenta>Swift没有初始化器</c>


55
00:03:29,910 --> 00:03:32,513 line:90%,end
<c.magenta>Swift不允许特定类型的</c>
<c.magenta>未对齐数据结构</c>


56
00:03:32,579 --> 00:03:34,481 line:90%,end
<c.magenta>这样的结构会延长启动时间</c>


57
00:03:34,548 --> 00:03:36,617 line:90%,end
<c.magenta>总的来说 转向Swift</c>


58
00:03:36,683 --> 00:03:41,388 line:90%,end
<c.magenta>让你更容易获得快速的程序启动</c>


59
00:03:42,523 --> 00:03:45,993 line:90%,end
<c.magenta>Swift代码更精简</c>
<c.magenta>因此性能更好</c>


60
00:03:46,059 --> 00:03:48,762 line:90%,end
<c.magenta>因此请转移到</c>
<c.magenta>我们今年发布的新Swift</c>


61
00:03:48,829 --> 00:03:51,532 line:90%,end
<c.magenta>将会提供更多的好处</c>


62
00:03:51,965 --> 00:03:54,902 line:90%,end
<c.magenta>现在我们来看</c>


63
00:03:57,371 --> 00:04:01,175 line:90%,end
<c.magenta>iOS 11和</c>
<c.magenta>macOS High Sierra中的新工具</c>


64
00:04:01,241 --> 00:04:05,012 line:90%,end
<c.magenta>我们在Instruments中</c>
<c.magenta>加入静态初始化器跟踪</c>


65
00:04:05,078 --> 00:04:06,413 line:90%,end
<c.magenta>缩短应用启动时间</c>


66
00:04:06,480 --> 00:04:09,983 line:90%,end
<c.magenta>这是非常不错的功能</c>
<c.magenta>因为初始化器是代码</c>


67
00:04:10,050 --> 00:04:13,453 line:90%,end
<c.magenta>它们在main函数之前运行</c>
<c.magenta>为你设置对象</c>


68
00:04:13,520 --> 00:04:16,557 line:90%,end
<c.magenta>你并不能透彻地</c>
<c.magenta>了解main执行之前的情况</c>


69
00:04:17,391 --> 00:04:19,625 line:90%,end
<c.magenta>现在Instruments</c>
<c.magenta>增加这个功能</c>


70
00:04:19,692 --> 00:04:22,596 line:90%,end
<c.magenta>提供每个静态初始化器的准确时间</c>


71
00:04:22,663 --> 00:04:25,432 line:90%,end
<c.magenta>现在我进行演示</c>


72
00:04:25,732 --> 00:04:31,438 line:90%,end
<c.magenta>这里有一个应用</c>
<c.magenta>与WWDC上的大多数应用一样</c>


73
00:04:31,505 --> 00:04:34,474 line:90%,end
<c.magenta>它也使用一些可爱的动物图片</c>


74
00:04:35,142 --> 00:04:36,410 line:90%,end
<c.magenta>让我启动它</c>


75
00:04:37,744 --> 00:04:41,248 line:90%,end
<c.magenta>这需要一定时间</c>


76
00:04:42,649 --> 00:04:45,152 line:90%,end
<c.magenta>还需要一点时间</c>


77
00:04:45,219 --> 00:04:48,755 line:10%
<c.magenta>启动后 我们看到几只灰鼠和猫</c>


78
00:04:50,791 --> 00:04:54,962 line:90%,end
<c.magenta>让我们来看为什么</c>
<c.magenta>需要这么长的启动时间</c>


79
00:04:55,596 --> 00:04:58,765 line:90%,end
<c.magenta>我会在Instruments中</c>
<c.magenta>进行分析</c>


80
00:04:58,832 --> 00:05:04,238 line:90%,end
<c.magenta>我停止执行这行代码</c>
<c.magenta>然后运行</c>


81
00:05:05,973 --> 00:05:09,710 line:90%,end
<c.magenta>现在我启动一个空模板</c>


82
00:05:10,944 --> 00:05:13,480 line:90%,end
<c.magenta>添加新静态初始化器工具</c>


83
00:05:15,849 --> 00:05:17,551 line:90%,end
<c.magenta>就在这里</c>


84
00:05:17,618 --> 00:05:19,720 line:90%,end
<c.magenta>然后我添加一个</c>
<c.magenta>Time Profiler</c>


85
00:05:19,786 --> 00:05:22,422 line:90%,end
<c.magenta>这样就很容易看到运行情况</c>


86
00:05:28,295 --> 00:05:29,129 line:90%,end
<c.magenta>开始运行</c>


87
00:05:29,830 --> 00:05:33,433 line:90%,end
<c.magenta>设置好这些工具之后</c>
<c.magenta>我们开始运行程序</c>


88
00:05:35,235 --> 00:05:37,704 line:90%,end
<c.magenta>我们获得跟踪数据</c>


89
00:05:38,906 --> 00:05:41,008 line:90%,end
<c.magenta>还没有出现</c>


90
00:05:41,074 --> 00:05:44,378 line:90%,end
<c.magenta>现在出现了</c>
<c.magenta>在背景中可以看到</c>


91
00:05:45,646 --> 00:05:47,014 line:90%,end
<c.magenta>出现显示内容</c>


92
00:05:47,080 --> 00:05:49,683 line:90%,end
<c.magenta>我会放大</c>
<c.magenta>让你们看得更清楚</c>


93
00:05:50,350 --> 00:05:53,453 line:90%,end
<c.magenta>这里有一个函数名为</c>
<c.magenta>waitForNetworkDebugger</c>


94
00:05:53,520 --> 00:05:54,955 line:90%,end
<c.magenta>这是正确的</c>
<c.magenta>因为我正在从网站</c>


95
00:05:55,022 --> 00:05:58,125 line:90%,end
<c.magenta>加载数据源</c>


96
00:05:58,692 --> 00:06:00,561 line:90%,end
<c.magenta>我尝试进行调试</c>


97
00:06:00,627 --> 00:06:04,898 line:90%,end
<c.magenta>让我们来看CPU Usage工具</c>


98
00:06:04,965 --> 00:06:10,771 line:90%,end
<c.magenta>可以看到初始化器运行时间</c>
<c.magenta>与CPU占用时间基本相同</c>


99
00:06:11,271 --> 00:06:14,107 line:90%,end
<c.magenta>在这里 可以看到dyld</c>


100
00:06:15,609 --> 00:06:20,614 line:10%
<c.magenta>如果我这样做</c>
<c.magenta>可以看到哪些处理占用时间</c>


101
00:06:21,148 --> 00:06:24,952 line:10%
<c.magenta>所用时间为9.5秒</c>


102
00:06:25,018 --> 00:06:29,823 line:10%
<c.magenta>初始化器占用9.5秒</c>
<c.magenta>我们展开很多层</c>


103
00:06:29,890 --> 00:06:33,160 line:10%
<c.magenta>通常你不用这样做</c>
<c.magenta>我是为了让你们看清楚运行情况</c>


104
00:06:34,728 --> 00:06:38,298 line:10%
<c.magenta>在这里我们可以看到</c>
<c.magenta>waitForNetworkDebugger</c>


105
00:06:38,365 --> 00:06:40,000 line:10%
<c.magenta>我们在初始化器调用中</c>
<c.magenta>见到过它</c>


106
00:06:40,067 --> 00:06:42,336 line:10%
<c.magenta>现在你很容易找到它</c>


107
00:06:42,703 --> 00:06:48,041 line:10%
<c.magenta>现在我返回Xcode</c>


108
00:06:48,509 --> 00:06:52,579 line:10%
<c.magenta>看到了</c>
<c.magenta>这是waitForNetworkDebugger调用</c>


109
00:06:52,646 --> 00:06:54,648 line:10%
<c.magenta>我使用C语言实现它</c>


110
00:06:54,715 --> 00:06:56,683 line:10%
<c.magenta>因为Swift不允许做这样的事情</c>


111
00:06:57,117 --> 00:07:01,088 line:10%
<c.magenta>我在这里创建构造函数</c>


112
00:07:01,154 --> 00:07:03,190 line:90%,end
<c.magenta>如果我返回源代码</c>


113
00:07:05,926 --> 00:07:09,930 line:90%,end
<c.magenta>我可以删除这个函数</c>


114
00:07:10,931 --> 00:07:12,866 line:90%,end
<c.magenta>因为它仅用于调试目的</c>


115
00:07:13,534 --> 00:07:18,238 line:10%
<c.magenta>如果运行 程序将会立即启动</c>


116
00:07:18,906 --> 00:07:21,542 line:90%,end
<c.magenta>因此我们可以快速地发现</c>


117
00:07:21,608 --> 00:07:24,144 line:90%,end
<c.magenta>哪些堆栈初始化器</c>
<c.magenta>导致启动变慢</c>


118
00:07:24,211 --> 00:07:27,047 line:90%,end
<c.magenta>这涉及多个dylib</c>


119
00:07:27,114 --> 00:07:29,383 line:90%,end
<c.magenta>包括系统dylib</c>
<c.magenta>这些系统库会占用很长时间</c>


120
00:07:29,449 --> 00:07:32,853 line:90%,end
<c.magenta>这是你为它们提供的输入造成的</c>
<c.magenta>比如复杂的nib文件</c>


121
00:07:33,487 --> 00:07:39,760 line:90%,end
<c.magenta>这依赖于High Sierra</c>
<c.magenta>和iOS 11的内核</c>


122
00:07:39,826 --> 00:07:43,597 line:90%,end
<c.magenta>和dyld中的新基础结构</c>
<c.magenta>你需要新生成程序才能看到这些信息</c>


123
00:07:43,897 --> 00:07:46,867 line:90%,end
<c.magenta>现在可以捕获大多数初始化器</c>
<c.magenta>我们还在努力捕获</c>


124
00:07:46,934 --> 00:07:50,737 line:90%,end
<c.magenta>一些边界例子</c>
<c.magenta>但是目前你已经能够</c>


125
00:07:50,804 --> 00:07:54,608 line:90%,end
<c.magenta>快速地发现</c>
<c.magenta>是什么占用程序启动时间</c>


126
00:07:54,675 --> 00:07:57,711 line:90%,end
<c.magenta>让你能够解决问题</c>
<c.magenta>更快速地启动程序</c>


127
00:07:57,778 --> 00:07:59,279 line:90%,end
<c.magenta>提供更好的用户体验</c>


128
00:07:59,580 --> 00:08:00,447 line:90%,end
<c.magenta>谢谢</c>


129
00:08:05,552 --> 00:08:09,022 line:90%,end
<c.magenta>前面我说过</c>
<c.magenta>我们会简要地回顾dyld的历史</c>


130
00:08:10,023 --> 00:08:12,526 line:90%,end
<c.magenta>跨世纪的动态链接技术</c>


131
00:08:12,893 --> 00:08:15,762 line:90%,end
<c.magenta>很早以前我们就已经推出dyld</c>


132
00:08:15,829 --> 00:08:19,199 line:90%,end
<c.magenta>它们没有版本号</c>


133
00:08:19,266 --> 00:08:23,770 line:90%,end
<c.magenta>这是dyld 1</c>
<c.magenta>包含在NeXTStep 3.3中</c>


134
00:08:24,972 --> 00:08:26,640 line:90%,end
<c.magenta>可以追溯到1996年</c>


135
00:08:26,707 --> 00:08:31,645 line:90%,end
<c.magenta>此前 NeXT使用静态二进制数据</c>


136
00:08:32,513 --> 00:08:38,552 line:90%,end
<c.magenta>作用并不是很大 其历史早于</c>
<c.magenta>标准化POSIX dlopen调用</c>


137
00:08:38,619 --> 00:08:40,854 line:90%,end
<c.magenta>现在dlopen还存在于</c>
<c.magenta>某些Unix之中</c>


138
00:08:40,921 --> 00:08:44,591 line:90%,end
<c.magenta>它们是一些专用扩展</c>
<c.magenta>被开发者所采用</c>


139
00:08:45,092 --> 00:08:48,061 line:90%,end
<c.magenta>NeXTStep</c>
<c.magenta>具有不同的专用扩展</c>


140
00:08:48,128 --> 00:08:52,399 line:90%,end
<c.magenta>因此开发者在macOS 10</c>
<c.magenta>的早期版本上编写第三方包装器</c>


141
00:08:52,466 --> 00:08:54,401 line:90%,end
<c.magenta>以支持标准Unix软件</c>


142
00:08:54,768 --> 00:08:58,005 line:90%,end
<c.magenta>问题是这些包装器</c>
<c.magenta>并不能完美地支持相同的语义</c>


143
00:08:58,071 --> 00:09:00,607 line:90%,end
<c.magenta>因此可能有一些边界例子</c>
<c.magenta>不能正常工作</c>


144
00:09:00,674 --> 00:09:02,743 line:90%,end
<c.magenta>因此会造成运行缓慢</c>


145
00:09:03,143 --> 00:09:07,848 line:90%,end
<c.magenta>它是在大多数使用</c>
<c.magenta>C++ 动态库的系统之前编写的</c>


146
00:09:07,915 --> 00:09:09,149 line:90%,end
<c.magenta>这些知识很重要</c>


147
00:09:09,550 --> 00:09:13,520 line:90%,end
<c.magenta>C++ 有许多的特性</c>
<c.magenta>比如其初始化器排序方式等</c>


148
00:09:13,587 --> 00:09:17,791 line:90%,end
<c.magenta>它们在静态环境中工作良好</c>


149
00:09:17,858 --> 00:09:20,027 line:90%,end
<c.magenta>但是在动态环境中</c>


150
00:09:20,093 --> 00:09:22,930 line:90%,end
<c.magenta>可能会降低性能</c>


151
00:09:23,030 --> 00:09:24,631 line:90%,end
<c.magenta>因此大型C++代码库</c>


152
00:09:24,698 --> 00:09:29,636 line:90%,end
<c.magenta>导致动态链接器</c>
<c.magenta>需要完成大量的工作 速度变慢</c>


153
00:09:33,140 --> 00:09:38,579 line:90%,end
<c.magenta>在发布macOS 10.0和</c>
<c.magenta>Cheetah前 我们还增加另外一个特性</c>


154
00:09:38,645 --> 00:09:40,113 line:90%,end
<c.magenta>名称为预绑定</c>


155
00:09:40,581 --> 00:09:44,685 line:90%,end
<c.magenta>你们一些人知道预绑定技术</c>


156
00:09:46,220 --> 00:09:48,622 line:90%,end
<c.magenta>我知道你们会感到困惑</c>


157
00:09:48,689 --> 00:09:52,392 line:90%,end
<c.magenta>我们使用预绑定技术</c>
<c.magenta>为系统中的所有dylib和你的程序</c>


158
00:09:52,459 --> 00:09:56,330 line:90%,end
<c.magenta>找到固定地址</c>


159
00:09:56,630 --> 00:09:59,967 line:90%,end
<c.magenta>动态加载器将会</c>
<c.magenta>加载这些地址的所有内容</c>


160
00:10:00,033 --> 00:10:04,104 line:90%,end
<c.magenta>如果成功 将会编辑</c>
<c.magenta>所有这些二进制数据</c>


161
00:10:04,171 --> 00:10:07,241 line:90%,end
<c.magenta>以获得所有预计算地址</c>
<c.magenta>然后下次</c>


162
00:10:07,307 --> 00:10:10,878 line:90%,end
<c.magenta>当它将所有数据放入相同地址时</c>
<c.magenta>不必进行任何其它额外的工作</c>


163
00:10:11,144 --> 00:10:13,580 line:90%,end
<c.magenta>这会大幅提高速度</c>


164
00:10:14,248 --> 00:10:19,086 line:90%,end
<c.magenta>但是这也意味着</c>
<c.magenta>每次启动时会编辑你的二进制数据</c>


165
00:10:19,520 --> 00:10:22,256 line:90%,end
<c.magenta>这并不是很好的做法</c>


166
00:10:22,322 --> 00:10:23,991 line:90%,end
<c.magenta>至少从安全性来说是如此</c>


167
00:10:25,893 --> 00:10:29,530 line:90%,end
<c.magenta>后来我们推出dyld 2</c>
<c.magenta>它是macOS Tiger的组成部分</c>


168
00:10:30,264 --> 00:10:34,234 line:90%,end
<c.magenta>dyld 2是dyld的</c>
<c.magenta>完全重写版本</c>


169
00:10:36,069 --> 00:10:38,805 line:90%,end
<c.magenta>正确支持C++初始化器语义</c>


170
00:10:38,872 --> 00:10:44,511 line:90%,end
<c.magenta>我们扩展mach-o格式</c>
<c.magenta>并且更新dyld</c>


171
00:10:44,578 --> 00:10:47,347 line:90%,end
<c.magenta>从而获得高效率的C++库支持</c>


172
00:10:47,848 --> 00:10:51,251 line:90%,end
<c.magenta>它具有完整的本机dlopen</c>
<c.magenta>和dlsym实现</c>


173
00:10:51,318 --> 00:10:54,988 line:90%,end
<c.magenta>具有正确的语义</c>
<c.magenta>我们弃用旧版API</c>


174
00:10:55,055 --> 00:10:58,992 line:90%,end
<c.magenta>这些旧版API仍然位于macOS中</c>
<c.magenta>没有加入到我们的任何其它平台上</c>


175
00:11:00,827 --> 00:11:02,996 line:90%,end
<c.magenta>dyld的设计目标是提高速度</c>


176
00:11:03,463 --> 00:11:06,934 line:90%,end
<c.magenta>因此仅进行有限的健全性检查</c>


177
00:11:07,000 --> 00:11:10,237 line:90%,end
<c.magenta>以前 恶意程序并不多</c>


178
00:11:11,271 --> 00:11:15,142 line:10%
<c.magenta>由于它有一些安全问题</c>


179
00:11:15,209 --> 00:11:20,414 line:10%
<c.magenta>因此我们对一些功能进行改进</c>
<c.magenta>提高它在现在平台上的安全性</c>


180
00:11:21,215 --> 00:11:25,185 line:10%
<c.magenta>由于其速度大幅提升</c>
<c.magenta>因此我们可以减少预绑定工作量</c>


181
00:11:25,252 --> 00:11:30,524 line:10%
<c.magenta>不同于编辑你的程序数据</c>
<c.magenta>我们仅编辑系统库</c>


182
00:11:30,591 --> 00:11:33,927 line:10%
<c.magenta>可以仅在软件更新时</c>
<c.magenta>做这些事情</c>


183
00:11:33,994 --> 00:11:37,097 line:10%
<c.magenta>因此在软件安装过程中</c>


184
00:11:37,164 --> 00:11:41,735 line:10%
<c.magenta>你可能会看到</c>
<c.magenta>“优化系统性能”之类的文字</c>


185
00:11:41,802 --> 00:11:46,473 line:10%
<c.magenta>这时就是在更新预绑定</c>


186
00:11:46,540 --> 00:11:48,909 line:10%
<c.magenta>现在dyld用于所有优化</c>


187
00:11:48,976 --> 00:11:50,477 line:10%
<c.magenta>其用途就是优化</c>


188
00:11:51,745 --> 00:11:54,414 line:10%
<c.magenta>因此后来我们发布了dyld 2</c>


189
00:11:55,215 --> 00:11:59,386 line:90%,end
<c.magenta>在过去几年我们进行大量改进</c>
<c.magenta>性能显著提高</c>


190
00:11:59,453 --> 00:12:04,258 line:90%,end
<c.magenta>首先 我们增加了</c>
<c.magenta>大量的基础结构和平台</c>


191
00:12:05,158 --> 00:12:07,961 line:90%,end
<c.magenta>自从dyld 2</c>
<c.magenta>在PowerPC发布之后</c>


192
00:12:08,028 --> 00:12:13,033 line:90%,end
<c.magenta>我们增加了x86、 x86 64 arm</c>
<c.magenta>arm64和许多的衍生平台</c>


193
00:12:13,667 --> 00:12:16,170 line:90%,end
<c.magenta>我们还推出iOS、tvOS</c>
<c.magenta>和watchOS</c>


194
00:12:16,236 --> 00:12:18,939 line:90%,end
<c.magenta>它们全部都需要新dyld功能</c>


195
00:12:20,040 --> 00:12:23,177 line:90%,end
<c.magenta>我们通过多种方式增强安全性</c>


196
00:12:23,710 --> 00:12:26,980 line:90%,end
<c.magenta>增加代码签名和ASLR</c>


197
00:12:27,047 --> 00:12:30,384 line:90%,end
<c.magenta>也就是地址空间配置随机加载</c>


198
00:12:31,185 --> 00:12:33,253 line:90%,end
<c.magenta>这意味着每次你加载库</c>


199
00:12:33,320 --> 00:12:34,788 line:90%,end
<c.magenta>它可能位于不同的地址</c>


200
00:12:35,455 --> 00:12:38,759 line:90%,end
<c.magenta>如果想要了解更多详细信息</c>
<c.magenta>请观看去年的演讲</c>


201
00:12:38,825 --> 00:12:43,897 line:90%,end
<c.magenta>在此演讲中Nick详细介绍了</c>
<c.magenta>如何启动程序</c>


202
00:12:43,964 --> 00:12:46,066 line:90%,end
<c.magenta>最后 我们增加了</c>
<c.magenta>mach-o文件头中的项目</c>


203
00:12:46,133 --> 00:12:48,001 line:90%,end
<c.magenta>这是重要的边界检查功能</c>


204
00:12:48,068 --> 00:12:51,772 line:90%,end
<c.magenta>从而可以避免恶意二进制数据的加入</c>


205
00:12:52,906 --> 00:12:55,776 line:90%,end
<c.magenta>最后 我们增强了性能</c>


206
00:12:55,843 --> 00:12:59,580 line:10%
<c.magenta>因此我们可以消除预绑定</c>


207
00:12:59,646 --> 00:13:02,616 line:10%
<c.magenta>转而使用共享代码</c>


208
00:13:03,150 --> 00:13:05,085 line:10%
<c.magenta>那么什么是共享代码？</c>


209
00:13:06,286 --> 00:13:10,958 line:90%,end
<c.magenta>共享代码最早被引入和iOS 3.1</c>
<c.magenta>和macOS Snow Leopard</c>


210
00:13:11,825 --> 00:13:14,161 line:90%,end
<c.magenta>并且完全取代预绑定</c>


211
00:13:14,895 --> 00:13:18,565 line:90%,end
<c.magenta>它是一个单文件</c>
<c.magenta>含有大多数系统dylib</c>


212
00:13:18,999 --> 00:13:20,734 line:90%,end
<c.magenta>由于合并成一个文件</c>


213
00:13:20,801 --> 00:13:22,736 line:90%,end
<c.magenta>因此可以进行优化</c>


214
00:13:22,970 --> 00:13:25,272 line:90%,end
<c.magenta>我们重新调整所有文本段</c>


215
00:13:25,339 --> 00:13:28,675 line:90%,end
<c.magenta>和所有数据段重写整个符号表</c>


216
00:13:28,742 --> 00:13:33,180 line:90%,end
<c.magenta>以减小大小</c>
<c.magenta>从而在每个进程中</c>


217
00:13:33,247 --> 00:13:34,781 line:90%,end
<c.magenta>仅挂载少量的区域</c>


218
00:13:35,315 --> 00:13:38,852 line:90%,end
<c.magenta>它允许我们打包二进制数据段</c>
<c.magenta>节省大量的RAM</c>


219
00:13:39,720 --> 00:13:42,823 line:90%,end
<c.magenta>它实际上是dylib预链接器</c>


220
00:13:43,423 --> 00:13:47,327 line:90%,end
<c.magenta>我并不会讨论特定的优化结果</c>


221
00:13:47,728 --> 00:13:50,898 line:90%,end
<c.magenta>但是它的RAM节约是显著的</c>
<c.magenta>在普通iOS系统上</c>


222
00:13:50,964 --> 00:13:55,836 line:90%,end
<c.magenta>运行时可以节约500M-1GB内存</c>


223
00:13:57,571 --> 00:14:01,208 line:90%,end
<c.magenta>它还预生成数据结构</c>
<c.magenta>供dyld和Ob-C</c>


224
00:14:01,275 --> 00:14:03,911 line:90%,end
<c.magenta>在运行时使用</c>
<c.magenta>让我们不必在程序启动时做这些事情</c>


225
00:14:03,977 --> 00:14:06,513 line:90%,end
<c.magenta>这也会节约更多RAM和时间</c>


226
00:14:07,748 --> 00:14:12,186 line:10%
<c.magenta>共享代码在macOS上本地生成</c>
<c.magenta>运行dyld共享代码</c>


227
00:14:12,252 --> 00:14:14,688 line:10%
<c.magenta>将会大幅优化系统性能</c>


228
00:14:14,755 --> 00:14:16,623 line:10%
<c.magenta>并且带来其它好处</c>


229
00:14:16,890 --> 00:14:19,860 line:90%,end
<c.magenta>在我们的其它平台上</c>
<c.magenta>我们在Apple生成共享代码</c>


230
00:14:19,927 --> 00:14:21,061 line:90%,end
<c.magenta>然后提供给你</c>


231
00:14:22,629 --> 00:14:24,865 line:90%,end
<c.magenta>刚才我讨论了共享代码</c>


232
00:14:24,932 --> 00:14:27,768 line:90%,end
<c.magenta>接下来我介绍dyld 3</c>


233
00:14:28,735 --> 00:14:33,473 line:90%,end
<c.magenta>dyld 3是全新的动态链接器</c>
<c.magenta>今天我们宣布推出它</c>


234
00:14:34,641 --> 00:14:37,411 line:90%,end
<c.magenta>它完全改变动态链接概念</c>


235
00:14:38,445 --> 00:14:42,816 line:90%,end
<c.magenta>将成为大多数</c>


236
00:14:42,883 --> 00:14:44,484 line:90%,end
<c.magenta>macOS系统程序的默认设置</c>


237
00:14:45,719 --> 00:14:48,355 line:90%,end
<c.magenta>2017 Apple OS平台上的</c>
<c.magenta>所有系统程序</c>


238
00:14:48,422 --> 00:14:52,025 line:90%,end
<c.magenta>都会默认使用它</c>


239
00:14:53,660 --> 00:14:57,297 line:90%,end
<c.magenta>在未来的Apple OS平台</c>
<c.magenta>和第三方程序中</c>


240
00:14:57,364 --> 00:14:59,333 line:90%,end
<c.magenta>它将会全面取代dyld2</c>


241
00:15:00,300 --> 00:15:04,271 line:90%,end
<c.magenta>那么 我们为什么要再次使用</c>
<c.magenta>动态链接器呢？</c>


242
00:15:06,373 --> 00:15:08,675 line:90%,end
<c.magenta>首先是为了性能</c>


243
00:15:08,742 --> 00:15:10,511 line:90%,end
<c.magenta>性能是一个永恒的主题</c>


244
00:15:10,577 --> 00:15:13,647 line:90%,end
<c.magenta>我们想要尽量提高启动速度</c>


245
00:15:14,381 --> 00:15:17,184 line:90%,end
<c.magenta>我们认为 它可以帮助</c>


246
00:15:17,251 --> 00:15:19,219 line:90%,end
<c.magenta>我们获得最快的</c>


247
00:15:19,286 --> 00:15:22,723 line:90%,end
<c.magenta>程序启动和运行速度</c>


248
00:15:23,423 --> 00:15:29,329 line:90%,end
<c.magenta>其次是安全性 前面我说过</c>
<c.magenta>我们在dyld2中增加了些安全特性</c>


249
00:15:29,396 --> 00:15:32,366 line:90%,end
<c.magenta>但是很难跟随现实情形</c>
<c.magenta>增强安全性</c>


250
00:15:32,533 --> 00:15:35,335 line:90%,end
<c.magenta>过去几年我们做了很多的工作</c>


251
00:15:35,402 --> 00:15:38,839 line:90%,end
<c.magenta>但是难以实现这个目标</c>


252
00:15:39,740 --> 00:15:42,109 line:90%,end
<c.magenta>那么我们是否能够</c>
<c.magenta>进行更积极的安全检查</c>


253
00:15:42,176 --> 00:15:44,178 line:90%,end
<c.magenta>并且从设计上提高安全性？</c>


254
00:15:45,112 --> 00:15:48,148 line:90%,end
<c.magenta>最后是可测试性和可靠性</c>


255
00:15:48,482 --> 00:15:50,317 line:90%,end
<c.magenta>我们能否让dyld变得更容易测试？</c>


256
00:15:50,384 --> 00:15:53,921 line:90%,end
<c.magenta>为此Apple发布了很多不错的</c>
<c.magenta>测试框架 比如XCTest</c>


257
00:15:53,987 --> 00:15:56,690 line:90%,end
<c.magenta>我们应该使用它们</c>


258
00:15:56,757 --> 00:15:59,459 line:90%,end
<c.magenta>但是它们依赖于</c>
<c.magenta>动态链接器的底层功能</c>


259
00:15:59,526 --> 00:16:03,897 line:90%,end
<c.magenta>将它们的库插入进程</c>
<c.magenta>因此它们不能用于</c>


260
00:16:03,964 --> 00:16:05,933 line:90%,end
<c.magenta>测试现有的dyld代码</c>


261
00:16:05,999 --> 00:16:09,703 line:90%,end
<c.magenta>这让我们难以测试安全性和性能水平</c>


262
00:16:10,938 --> 00:16:13,440 line:90%,end
<c.magenta>我们应该如何做呢？</c>


263
00:16:13,507 --> 00:16:17,177 line:90%,end
<c.magenta>我们将大多数dyld移出进程</c>


264
00:16:19,079 --> 00:16:21,882 line:90%,end
<c.magenta>现在它只是普通的后台程序</c>


265
00:16:21,949 --> 00:16:25,285 line:90%,end
<c.magenta>可以使用标准测试工具进行测试</c>


266
00:16:25,352 --> 00:16:26,186 line:90%,end
<c.magenta>这让我们以后</c>


267
00:16:26,253 --> 00:16:28,956 line:90%,end
<c.magenta>进一步提高速度和性能</c>


268
00:16:30,157 --> 00:16:35,095 line:90%,end
<c.magenta>另外也允许部分dyld</c>
<c.magenta>驻留在进程之中</c>


269
00:16:35,162 --> 00:16:40,367 line:90%,end
<c.magenta>但是驻留部分尽可小</c>
<c.magenta>从而减少程序的受攻击面积</c>


270
00:16:42,135 --> 00:16:45,772 line:90%,end
<c.magenta>由于代码速度提升</c>


271
00:16:45,839 --> 00:16:47,708 line:90%,end
<c.magenta>因此会提高启动速度</c>


272
00:16:48,542 --> 00:16:51,545 line:10%
<c.magenta>代码运行速度是前所未有的</c>


273
00:16:52,379 --> 00:16:53,780 line:10%
<c.magenta>为了让你知道我们是如何做到的</c>


274
00:16:53,847 --> 00:16:57,985 line:10%
<c.magenta>我将简要演示</c>
<c.magenta>dyld 2如何启动程序</c>


275
00:16:58,051 --> 00:17:01,855 line:10%
<c.magenta>在去年的“缩短程序启动时间”演讲中</c>


276
00:17:01,922 --> 00:17:04,458 line:90%,end
<c.magenta>我们更详细地讨论了这个主题</c>


277
00:17:04,525 --> 00:17:06,593 line:90%,end
<c.magenta>你可以观看那个演讲视频</c>


278
00:17:06,660 --> 00:17:08,095 line:90%,end
<c.magenta>这是一个不错的主意</c>


279
00:17:08,262 --> 00:17:11,865 line:90%,end
<c.magenta>当然你也可以听我的演讲</c>
<c.magenta>我会简要介绍</c>


280
00:17:12,699 --> 00:17:16,637 line:10%
<c.magenta>我们使用dyld 2</c>
<c.magenta>你的程序开始启动</c>


281
00:17:16,703 --> 00:17:19,006 line:10%
<c.magenta>我们需要分析你的mach-o文件</c>


282
00:17:19,306 --> 00:17:22,276 line:10%
<c.magenta>弄清楚你需要哪些库</c>


283
00:17:22,776 --> 00:17:27,247 line:10%
<c.magenta>它们可能需要其它库</c>
<c.magenta>我们进行递归分析</c>


284
00:17:27,314 --> 00:17:29,483 line:10%
<c.magenta>直到获得所有dylib的完整图</c>


285
00:17:29,550 --> 00:17:33,820 line:10%
<c.magenta>普通iOS程序</c>
<c.magenta>需要3-600个dylib</c>


286
00:17:33,887 --> 00:17:35,622 line:10%
<c.magenta>数据庞大 需要进行大量的处理</c>


287
00:17:36,924 --> 00:17:41,328 line:10%
<c.magenta>然后我们映射到所有mach-o文件</c>
<c.magenta>将它们放入地址空间</c>


288
00:17:42,462 --> 00:17:45,499 line:10%
<c.magenta>然后执行符号查找</c>


289
00:17:45,566 --> 00:17:47,167 line:10%
<c.magenta>若你的程序使用printf函数</c>


290
00:17:47,234 --> 00:17:50,003 line:10%
<c.magenta>将会查找printf是否在库系统中</c>


291
00:17:50,504 --> 00:17:51,872 line:10%
<c.magenta>然后我们找到它的地址</c>


292
00:17:51,939 --> 00:17:55,275 line:10%
<c.magenta>将它复制到你的程序中的函数指针</c>


293
00:17:56,577 --> 00:17:59,112 line:10%
<c.magenta>我们进行绑定和基址重置</c>


294
00:17:59,179 --> 00:18:03,283 line:10%
<c.magenta>复制这些指针</c>
<c.magenta>由于使用随机地址</c>


295
00:18:03,350 --> 00:18:06,486 line:10%
<c.magenta>所有指针必须使用基址</c>


296
00:18:07,454 --> 00:18:09,489 line:10%
<c.magenta>最后 我们可以运行</c>
<c.magenta>你的所有初始化器</c>


297
00:18:09,556 --> 00:18:11,558 line:10%
<c.magenta>因此前面我展示这个工具</c>


298
00:18:11,625 --> 00:18:13,827 line:10%
<c.magenta>这时 我们准备执行main函数</c>


299
00:18:13,894 --> 00:18:15,395 line:10%
<c.magenta>这里进行了大量的工作</c>


300
00:18:15,929 --> 00:18:19,266 line:10%
<c.magenta>我们如何加快其速度</c>
<c.magenta>将这些步骤移出进程呢？</c>


301
00:18:19,333 --> 00:18:23,837 line:90%,end
<c.magenta>首先我确定安全敏感性组件</c>


302
00:18:24,104 --> 00:18:26,773 line:90%,end
<c.magenta>从我们的角度来看</c>
<c.magenta>最大的安全隐患之一</c>


303
00:18:26,840 --> 00:18:29,943 line:90%,end
<c.magenta>分析mach-o文件头</c>
<c.magenta>和查找依赖关系</c>


304
00:18:30,010 --> 00:18:34,014 line:90%,end
<c.magenta>因此人们可以使用</c>
<c.magenta>撰改过的mach-o文件头进行攻击</c>


305
00:18:34,081 --> 00:18:39,152 line:90%,end
<c.magenta>而且你 的程序可能使用</c>
<c.magenta>@rpaths 它们是搜索路径</c>


306
00:18:39,219 --> 00:18:43,190 line:90%,end
<c.magenta>通过撰改这些路径</c>
<c.magenta>或者将库插到适当的位置</c>


307
00:18:43,257 --> 00:18:45,292 line:90%,end
<c.magenta>可以破坏程序</c>


308
00:18:45,459 --> 00:18:49,062 line:90%,end
<c.magenta>因此我们在后台程序的进程之外</c>
<c.magenta>完成所有这些工作</c>


309
00:18:49,630 --> 00:18:53,734 line:90%,end
<c.magenta>然后我们确定大量占用资源的部分</c>
<c.magenta>也就是占用缓冲的部分</c>


310
00:18:53,800 --> 00:18:56,937 line:90%,end
<c.magenta>它们是符号查找</c>
<c.magenta>因为在给定的库中</c>


311
00:18:57,004 --> 00:19:00,774 line:10%
<c.magenta>除非进行软件更新</c>
<c.magenta>或者在磁盘上更改库</c>


312
00:19:00,841 --> 00:19:03,810 line:10%
<c.magenta>符号将始终位于库中的相同偏移位置</c>


313
00:19:04,311 --> 00:19:08,015 line:10%
<c.magenta>我们已经确定这些内容</c>
<c.magenta>我们来看它们在dyld3中是怎样的</c>


314
00:19:11,552 --> 00:19:15,923 line:10%
<c.magenta>我们将这些部分移到上层</c>
<c.magenta>然后向磁盘写入收尾处理</c>


315
00:19:15,989 --> 00:19:20,861 line:10%
<c.magenta>前面我说过 启动收尾处理</c>
<c.magenta>是启动程序的重要环节</c>


316
00:19:22,429 --> 00:19:29,303 line:10%
<c.magenta>稍后可以在进程中使用它</c>
<c.magenta>dyld 3包含这三个部分</c>


317
00:19:30,170 --> 00:19:33,407 line:10%
<c.magenta>它是一个进程外</c>
<c.magenta>mach-o分析器和编译器</c>


318
00:19:34,141 --> 00:19:37,678 line:10%
<c.magenta>也是一个进程内引擎</c>
<c.magenta>执行启动收尾处理</c>


319
00:19:38,779 --> 00:19:41,381 line:10%
<c.magenta>也是一个启动收尾缓存服务</c>


320
00:19:43,150 --> 00:19:45,786 line:10%
<c.magenta>大多数程序启动会使用缓存</c>


321
00:19:45,853 --> 00:19:48,555 line:10%
<c.magenta>但始终不需要调用进程外</c>
<c.magenta>mach-o分析器或编译器</c>


322
00:19:50,524 --> 00:19:53,760 line:10%
<c.magenta>启动收尾比mach-o更简单</c>


323
00:19:54,261 --> 00:19:57,731 line:10%
<c.magenta>它们是内存映射文件</c>
<c.magenta>不需要用复杂的方法进行分析</c>


324
00:19:57,798 --> 00:20:00,801 line:10%
<c.magenta>我们可以简单地验证它们</c>
<c.magenta>其作用是为了提高速度</c>


325
00:20:03,470 --> 00:20:06,340 line:90%,end
<c.magenta>让我们来详细看每个部分</c>


326
00:20:06,406 --> 00:20:10,077 line:90%,end
<c.magenta>因此 dyld 3</c>
<c.magenta>是进程外mach-o分析器</c>


327
00:20:10,844 --> 00:20:14,014 line:90%,end
<c.magenta>它解析所有搜索路径</c>


328
00:20:14,248 --> 00:20:16,316 line:90%,end
<c.magenta>所有rpaths</c>
<c.magenta>所有环境变量</c>


329
00:20:16,383 --> 00:20:17,851 line:90%,end
<c.magenta>它们会影响你的启动</c>


330
00:20:18,352 --> 00:20:20,687 line:90%,end
<c.magenta>然后分析mach-o二进制数据</c>


331
00:20:21,188 --> 00:20:23,223 line:90%,end
<c.magenta>执行所有符号查找</c>


332
00:20:25,192 --> 00:20:27,561 line:10%
<c.magenta>利用这些结果创建收尾处理</c>


333
00:20:28,495 --> 00:20:29,796 line:10%
<c.magenta>它是普通的后台程序</c>


334
00:20:29,863 --> 00:20:32,766 line:10%
<c.magenta>让我们提高测试基础架构的性能</c>


335
00:20:34,801 --> 00:20:37,671 line:90%,end
<c.magenta>dyld也是一个小型进程内引擎</c>


336
00:20:37,738 --> 00:20:40,007 line:90%,end
<c.magenta>这部分驻留在进程中</c>


337
00:20:40,073 --> 00:20:41,909 line:90%,end
<c.magenta>是你通常会看到的部分</c>


338
00:20:42,442 --> 00:20:46,213 line:90%,end
<c.magenta>它所做的事情是</c>
<c.magenta>检查启动收尾处理是否正确</c>


339
00:20:47,114 --> 00:20:50,651 line:90%,end
<c.magenta>然后映射到dylib之中</c>
<c.magenta>再跳转到main函数</c>


340
00:20:50,717 --> 00:20:52,519 line:90%,end
<c.magenta>你可能会注意到</c>


341
00:20:52,953 --> 00:20:56,590 line:10%
<c.magenta>dyld3不需要分析mach-o</c>
<c.magenta>文件头或执行符号查找</c>


342
00:20:56,657 --> 00:20:59,326 line:10%
<c.magenta>不需要做这些事情</c>
<c.magenta>就可以启动你的应用</c>


343
00:20:59,393 --> 00:21:01,895 line:10%
<c.magenta>由于这些是花费时间的部分</c>


344
00:21:02,296 --> 00:21:05,132 line:10%
<c.magenta>因此可以极大提高程序启动速度</c>


345
00:21:06,600 --> 00:21:11,371 line:90%,end
<c.magenta>最后 dyld 3</c>
<c.magenta>还是一个启动收尾缓存服务</c>


346
00:21:11,438 --> 00:21:14,241 line:90%,end
<c.magenta>这是什么意思呢？</c>


347
00:21:14,308 --> 00:21:18,946 line:90%,end
<c.magenta>我们将系统程序收尾</c>
<c.magenta>直接加入到共享缓存</c>


348
00:21:19,012 --> 00:21:22,449 line:90%,end
<c.magenta>我们已使用这个工具在系统中</c>
<c.magenta>运行和分析每个mach-o文件</c>


349
00:21:23,083 --> 00:21:26,320 line:90%,end
<c.magenta>我们可以直接将它们</c>
<c.magenta>放入共享缓存 使它映射到缓存中</c>


350
00:21:26,386 --> 00:21:30,357 line:90%,end
<c.magenta>所有dylib都使用它来启动</c>
<c.magenta>我们甚至不需要打开其它文件</c>


351
00:21:31,825 --> 00:21:37,397 line:90%,end
<c.magenta>对于第三方程序</c>
<c.magenta>我们在程序安装或系统更新</c>


352
00:21:37,464 --> 00:21:41,668 line:90%,end
<c.magenta>生成你的收尾处理</c>
<c.magenta>因为那时系统库已经发生更改</c>


353
00:21:41,768 --> 00:21:47,407 line:90%,end
<c.magenta>默认情况下 将在iOS、tvOS</c>
<c.magenta>和watchOS上生成收尾处理</c>


354
00:21:47,474 --> 00:21:48,909 line:90%,end
<c.magenta>甚至在程序运行之前</c>


355
00:21:49,843 --> 00:21:54,248 line:90%,end
<c.magenta>在macOS上 由于可以</c>
<c.magenta>侧向加载程序 如果需要</c>


356
00:21:54,314 --> 00:21:59,486 line:90%,end
<c.magenta>进程内引擎可以在首次启动时</c>
<c.magenta>RPC到后台程序</c>


357
00:22:00,521 --> 00:22:03,991 line:90%,end
<c.magenta>在此之后 能够使用缓存的收尾处理</c>


358
00:22:05,459 --> 00:22:09,696 line:90%,end
<c.magenta>正如前面我说的那样</c>
<c.magenta>在我们的其它平台上并不需要这样做</c>


359
00:22:10,664 --> 00:22:13,467 line:90%,end
<c.magenta>我介绍了今年我们将会用于系统程序的</c>


360
00:22:13,534 --> 00:22:16,303 line:90%,end
<c.magenta>这个新动态链接器</c>
<c.magenta>以后你们也会使用它</c>


361
00:22:16,436 --> 00:22:19,439 line:90%,end
<c.magenta>我想谈一谈可能会存在的问题</c>


362
00:22:19,506 --> 00:22:21,975 line:90%,end
<c.magenta>让你现在就可以开始更新你的程序</c>


363
00:22:22,709 --> 00:22:23,877 line:90%,end
<c.magenta>为DYLD 3而准备</c>


364
00:22:23,944 --> 00:22:27,881 line:90%,end
<c.magenta>首先它完全兼容dyld 2.x</c>


365
00:22:27,948 --> 00:22:31,518 line:90%,end
<c.magenta>因此一些现有API</c>


366
00:22:31,585 --> 00:22:35,989 line:90%,end
<c.magenta>会导致你的程序运行变慢</c>
<c.magenta>或者会在dyld 3中使用回退模式</c>


367
00:22:36,056 --> 00:22:39,226 line:90%,end
<c.magenta>我们希望你们避免这个问题</c>
<c.magenta>稍后我们再讨论这个问题</c>


368
00:22:39,293 --> 00:22:41,962 line:90%,end
<c.magenta>另外 你所做的一些优化</c>


369
00:22:42,029 --> 00:22:46,099 line:90%,end
<c.magenta>现在可能已经不再需要</c>


370
00:22:46,166 --> 00:22:49,403 line:90%,end
<c.magenta>因此不需要在这方面</c>
<c.magenta>花费过多力气</c>


371
00:22:49,603 --> 00:22:50,704 line:90%,end
<c.magenta>我想要说的另一件事情是</c>


372
00:22:50,771 --> 00:22:52,940 line:90%,end
<c.magenta>我们将会使用更严格的链接语义</c>


373
00:22:53,006 --> 00:22:53,907 line:90%,end
<c.magenta>这是什么意思？</c>


374
00:22:53,974 --> 00:22:59,780 line:90%,end
<c.magenta>很多的语义现在还无法使用</c>


375
00:22:59,847 --> 00:23:04,518 line:90%,end
<c.magenta>现在甚至是错误的</c>
<c.magenta>在加入新动态链接器时</c>


376
00:23:04,585 --> 00:23:06,920 line:90%,end
<c.magenta>我们发现很多这样的情况</c>


377
00:23:06,987 --> 00:23:09,256 line:90%,end
<c.magenta>目的是为了发现所有的边界例子</c>


378
00:23:09,590 --> 00:23:13,427 line:90%,end
<c.magenta>我们所做的事情</c>
<c.magenta>放入一个工作区以支持旧二进制数据</c>


379
00:23:14,127 --> 00:23:16,363 line:90%,end
<c.magenta>但是我们并不想更进一步</c>


380
00:23:16,430 --> 00:23:19,466 line:90%,end
<c.magenta>我们将会进行链接或后续检查</c>
<c.magenta>查看你使用哪些SDK</c>


381
00:23:19,533 --> 00:23:23,203 line:90%,end
<c.magenta>然后我们将禁用新二进制数据的工作区</c>


382
00:23:23,270 --> 00:23:27,341 line:90%,end
<c.magenta>让你能够解决这些问题</c>


383
00:23:28,408 --> 00:23:30,611 line:90%,end
<c.magenta>新二进制数据将会造成链接器问题</c>


384
00:23:31,945 --> 00:23:36,149 line:90%,end
<c.magenta>接下来我想讨论</c>
<c.magenta>数据段中的未对齐指针</c>


385
00:23:36,216 --> 00:23:37,384 line:90%,end
<c.magenta>我说的是什么意思呢？</c>


386
00:23:37,451 --> 00:23:40,187 line:90%,end
<c.magenta>假设你有一个全局性结构</c>


387
00:23:40,254 --> 00:23:43,824 line:90%,end
<c.magenta>指向一个函数</c>
<c.magenta>或另外一个全局性函数</c>


388
00:23:43,891 --> 00:23:46,927 line:90%,end
<c.magenta>在你的程序启动之前</c>
<c.magenta>我们必须修复这个指针</c>


389
00:23:46,994 --> 00:23:51,899 line:90%,end
<c.magenta>在我们的系统上</c>
<c.magenta>指针必须自然对齐以获得最佳性能</c>


390
00:23:53,166 --> 00:23:57,337 line:90%,end
<c.magenta>修复未对齐指针非常复杂</c>


391
00:23:57,571 --> 00:24:01,041 line:90%,end
<c.magenta>它们可能覆盖多个内存页</c>
<c.magenta>造成更多的内存页错误</c>


392
00:24:01,108 --> 00:24:03,744 line:90%,end
<c.magenta>和其它问题</c>
<c.magenta>这可能会产生与多处理器相关的</c>


393
00:24:04,378 --> 00:24:06,847 line:90%,end
<c.magenta>细微问题</c>


394
00:24:07,915 --> 00:24:10,851 line:90%,end
<c.magenta>静态链接器已经忽略这个警告</c>


395
00:24:12,252 --> 00:24:14,588 line:10%
<c.magenta>ld警告 指针地址未对齐</c>


396
00:24:14,655 --> 00:24:17,157 line:10%
<c.magenta>这是你的数据段所在的位置</c>


397
00:24:18,325 --> 00:24:19,860 line:10%
<c.magenta>如果你消除所有警告</c>


398
00:24:19,927 --> 00:24:22,596 line:10%
<c.magenta>那么问题已经得到解决</c>


399
00:24:23,030 --> 00:24:26,266 line:10%
<c.magenta>本周我们提供的源代码</c>
<c.magenta>存在一些Swift键径问题</c>


400
00:24:26,333 --> 00:24:28,669 line:10%
<c.magenta>但是它们将会被修复</c>
<c.magenta>你可以忽略这些问题</c>


401
00:24:28,735 --> 00:24:31,138 line:10%
<c.magenta>但是你们可以修复这些问题</c>


402
00:24:31,905 --> 00:24:34,374 line:10%
<c.magenta>如果你们想知道如何做</c>


403
00:24:34,441 --> 00:24:36,276 line:10%
<c.magenta>我将会展示给你们看</c>


404
00:24:36,343 --> 00:24:38,812 line:10%
<c.magenta>这需要大量的工作</c>


405
00:24:38,879 --> 00:24:41,782 line:90%,end
<c.magenta>但是你不能在Swift中做这些事情</c>


406
00:24:42,316 --> 00:24:45,519 line:90%,end
<c.magenta>请看这里的代码</c>


407
00:24:46,553 --> 00:24:51,058 line:90%,end
<c.magenta>这里有一些强制进行对齐的属性</c>


408
00:24:51,124 --> 00:24:54,127 line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>编译器将会为你进行正确的对齐</c>


409
00:24:54,194 --> 00:24:56,263 line:90%,end
<c.magenta>但是有些时候</c>
<c.magenta>你可能需要特殊的对齐</c>


410
00:24:56,330 --> 00:24:57,564 line:90%,end
<c.magenta>在本例中</c>


411
00:24:57,631 --> 00:25:00,133 line:90%,end
<c.magenta>默认对齐规则要求进行对齐</c>


412
00:25:00,200 --> 00:25:03,270 line:90%,end
<c.magenta>我使用了两种方法</c>
<c.magenta>但是结果很糟糕</c>


413
00:25:03,337 --> 00:25:04,872 line:90%,end
<c.magenta>你必须进行修复</c>


414
00:25:05,772 --> 00:25:09,576 line:90%,end
<c.magenta>然后我构建一个全局变量</c>


415
00:25:09,643 --> 00:25:12,246 line:90%,end
<c.magenta>这个变量在结构中设置指针</c>


416
00:25:12,312 --> 00:25:13,747 line:90%,end
<c.magenta>这将会强制动态链接器</c>


417
00:25:13,814 --> 00:25:16,650 line:90%,end
<c.magenta>在程序启动时修复指针</c>


418
00:25:17,217 --> 00:25:21,421 line:90%,end
<c.magenta>如果你看到这样的代码</c>
<c.magenta>可以清除所有对齐</c>


419
00:25:21,788 --> 00:25:24,892 line:90%,end
<c.magenta>重新调整结构</c>
<c.magenta>将指针放在前面</c>


420
00:25:24,958 --> 00:25:26,894 line:90%,end
<c.magenta>由于这更有利于对齐</c>


421
00:25:27,094 --> 00:25:29,396 line:90%,end
<c.magenta>关于C结构对齐</c>
<c.magenta>网上有很多的资料</c>


422
00:25:29,463 --> 00:25:31,265 line:90%,end
<c.magenta>你可以查看</c>


423
00:25:31,331 --> 00:25:34,368 line:90%,end
<c.magenta>但是希望你不必进行这样的处理</c>


424
00:25:34,434 --> 00:25:37,037 line:90%,end
<c.magenta>如果你编写Swift代码</c>
<c.magenta>你肯定不必这样做</c>


425
00:25:38,772 --> 00:25:42,342 line:90%,end
<c.magenta>接下来 我们讨论符号解析</c>


426
00:25:42,576 --> 00:25:43,844 line:90%,end
<c.magenta>这里的含义是什么？</c>


427
00:25:44,211 --> 00:25:47,481 line:90%,end
<c.magenta>dyld 2执行懒符号解析</c>


428
00:25:48,015 --> 00:25:51,218 line:90%,end
<c.magenta>dyld必须加载所有符号</c>


429
00:25:51,285 --> 00:25:53,687 line:90%,end
<c.magenta>这需要占用大量资源</c>
<c.magenta>因此应该使用缓存</c>


430
00:25:53,754 --> 00:26:00,294 line:90%,end
<c.magenta>直接运行现有程序</c>
<c.magenta>确实会占用很多资源</c>


431
00:26:00,360 --> 00:26:01,562 line:90%,end
<c.magenta>将会花费很长时间</c>


432
00:26:01,762 --> 00:26:05,866 line:90%,end
<c.magenta>为此我们使用一种机制</c>
<c.magenta>名称为懒符号解析</c>


433
00:26:05,933 --> 00:26:10,671 line:90%,end
<c.magenta>默认情况下 库中的函数指针</c>
<c.magenta>比如printf</c>


434
00:26:10,737 --> 00:26:12,105 line:90%,end
<c.magenta>并不指向printf</c>


435
00:26:12,439 --> 00:26:17,044 line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>它指向dyld中的一个函数</c>


436
00:26:17,110 --> 00:26:19,580 line:90%,end
<c.magenta>此函数返回一个</c>
<c.magenta>指向printf的函数指针</c>


437
00:26:20,113 --> 00:26:24,651 line:90%,end
<c.magenta>因此启动时</c>
<c.magenta>调用printf将会进入dyld</c>


438
00:26:24,718 --> 00:26:28,388 line:90%,end
<c.magenta>返回printf进行首次调用</c>


439
00:26:28,455 --> 00:26:30,958 line:90%,end
<c.magenta>然后第二次</c>
<c.magenta>你直接调用printf</c>


440
00:26:31,925 --> 00:26:35,495 line:90%,end
<c.magenta>由于我们已经缓存并且计算所有符号</c>


441
00:26:35,562 --> 00:26:37,264 line:90%,end
<c.magenta>因此在程序启动时不会产生额外开销</c>


442
00:26:37,331 --> 00:26:40,901 line:90%,end
<c.magenta>来绑定它们 我们将会这样做</c>


443
00:26:42,035 --> 00:26:46,974 line:90%,end
<c.magenta>当你这样做时</c>
<c.magenta>缺失符号的行为将会有所不同</c>


444
00:26:47,307 --> 00:26:51,078 line:90%,end
<c.magenta>在现有懒符号机制中</c>
<c.magenta>如果缺失一个符号</c>


445
00:26:51,144 --> 00:26:53,380 line:90%,end
<c.magenta>首次调用 将会正确启动</c>


446
00:26:53,447 --> 00:26:55,983 line:90%,end
<c.magenta>首次调用该符号</c>
<c.magenta>程序将会崩溃</c>


447
00:26:56,350 --> 00:26:59,253 line:90%,end
<c.magenta>如果使用勤符号 将会立即崩溃</c>


448
00:27:00,053 --> 00:27:00,988 line:90%,end
<c.magenta>为此…</c>


449
00:27:03,657 --> 00:27:05,993 line:10%
<c.magenta>我们提供一个兼容模式</c>


450
00:27:06,059 --> 00:27:07,828 line:10%
<c.magenta>我们要做的是</c>


451
00:27:08,529 --> 00:27:14,835 line:10%
<c.magenta>我们将导致自动崩溃的符号</c>
<c.magenta>放入dyld 3</c>


452
00:27:14,902 --> 00:27:17,971 line:10%
<c.magenta>如果不能找到你的符号</c>
<c.magenta>我们将会绑定该符号</c>


453
00:27:18,038 --> 00:27:19,673 line:10%
<c.magenta>因此首次调用将会崩溃</c>


454
00:27:20,207 --> 00:27:22,809 line:10%
<c.magenta>这是现在的SDK的工作模式</c>


455
00:27:22,876 --> 00:27:27,014 line:10%
<c.magenta>在未来的SDK中 我们将强制</c>
<c.magenta>预先进行所有符号解析</c>


456
00:27:27,080 --> 00:27:29,149 line:10%
<c.magenta>如果你缺失一个符号</c>
<c.magenta>将会崩溃</c>


457
00:27:29,216 --> 00:27:32,819 line:10%
<c.magenta>在开发过程中</c>
<c.magenta>你应该能够发现这些崩溃现象</c>


458
00:27:32,886 --> 00:27:35,355 line:10%
<c.magenta>而不是用户在程序运行时发现它们</c>


459
00:27:36,557 --> 00:27:38,325 line:10%
<c.magenta>现在你可以模拟这些行为</c>


460
00:27:38,392 --> 00:27:43,497 line:10%
<c.magenta>有一个特殊的链接器标记</c>
<c.magenta>即bind at load</c>


461
00:27:43,564 --> 00:27:47,401 line:10%
<c.magenta>如果你将它添加到你的调试程序</c>
<c.magenta>将会变得很慢</c>


462
00:27:47,467 --> 00:27:49,169 line:10%
<c.magenta>因此只应该放入调试版本</c>


463
00:27:49,236 --> 00:27:50,337 line:10%
<c.magenta>但将它添加到调试版本</c>


464
00:27:50,404 --> 00:27:53,373 line:10%
<c.magenta>你将会获得更可靠的行为</c>


465
00:27:53,440 --> 00:27:56,476 line:10%
<c.magenta>这让你能够好使用dyld 3</c>


466
00:27:57,845 --> 00:27:59,580 line:10%
<c.magenta>另外只应该在测试版本中使用</c>


467
00:28:00,647 --> 00:28:03,917 line:90%,end
<c.magenta>Dlopen、dlsym</c>
<c.magenta>和dladdr</c>


468
00:28:03,984 --> 00:28:07,454 line:90%,end
<c.magenta>去年我讲过</c>
<c.magenta>仅应该在十分必要时才使用它们</c>


469
00:28:07,521 --> 00:28:08,856 line:90%,end
<c.magenta>但我们理解你可能要使用它们</c>


470
00:28:08,922 --> 00:28:11,525 line:90%,end
<c.magenta>今年我也会讲这个问题</c>


471
00:28:11,892 --> 00:28:13,961 line:90%,end
<c.magenta>它们具有一些容易出错的语义</c>


472
00:28:14,728 --> 00:28:16,930 line:90%,end
<c.magenta>但是在一些情况下</c>
<c.magenta>仍然需要使用它们</c>


473
00:28:16,997 --> 00:28:19,867 line:90%,end
<c.magenta>特别是使用dlsym找到的符号</c>
<c.magenta>我们需要在运行时找到它们</c>


474
00:28:19,933 --> 00:28:21,235 line:90%,end
<c.magenta>我们不会提前知道这些符号</c>


475
00:28:21,301 --> 00:28:24,171 line:90%,end
<c.magenta>不能使用prefetching</c>
<c.magenta>和presearching</c>


476
00:28:24,571 --> 00:28:27,774 line:90%,end
<c.magenta>当你使用dlopen或dlsym</c>
<c.magenta>我们会读入以前未接触过的</c>


477
00:28:27,841 --> 00:28:31,078 line:90%,end
<c.magenta>所有符号表页</c>


478
00:28:31,411 --> 00:28:33,380 line:90%,end
<c.magenta>这会占用大量资源</c>


479
00:28:33,447 --> 00:28:38,785 line:90%,end
<c.magenta>此外 我们可能必须RPC到后台程序</c>


480
00:28:38,852 --> 00:28:41,021 line:90%,end
<c.magenta>这取决于其复杂程度</c>


481
00:28:41,088 --> 00:28:43,390 line:90%,end
<c.magenta>我们正在开发一些更好的替代方法</c>


482
00:28:43,857 --> 00:28:45,425 line:90%,end
<c.magenta>目前还没有完成</c>


483
00:28:45,492 --> 00:28:47,995 line:90%,end
<c.magenta>我们还需了解你们的用例</c>
<c.magenta>以确保我们开发出的方案</c>


484
00:28:48,061 --> 00:28:50,464 line:90%,end
<c.magenta>适合你们的需求</c>


485
00:28:50,531 --> 00:28:53,267 line:10%
<c.magenta>这些方案即将会发布</c>


486
00:28:53,333 --> 00:28:55,936 line:10%
<c.magenta>我们希望获得你们的反馈意见</c>


487
00:28:57,571 --> 00:28:59,873 line:90%,end
<c.magenta>接下来我想特别谈谈dlclose</c>


488
00:28:59,940 --> 00:29:02,509 line:90%,end
<c.magenta>dlclose是一个误用词</c>


489
00:29:02,576 --> 00:29:04,111 line:90%,end
<c.magenta>它是一个Unix API</c>


490
00:29:04,178 --> 00:29:05,646 line:90%,end
<c.magenta>如果在我们的系统上编写它</c>


491
00:29:05,712 --> 00:29:08,615 line:90%,end
<c.magenta>我们会将它命名为dlrelease</c>


492
00:29:08,682 --> 00:29:11,251 line:90%,end
<c.magenta>因为它实际上并不关闭dylib</c>


493
00:29:11,318 --> 00:29:14,855 line:90%,end
<c.magenta>它减少refcount计数</c>
<c.magenta>如果refcount变为0</c>


494
00:29:14,922 --> 00:29:16,123 line:90%,end
<c.magenta>将会关闭它</c>


495
00:29:16,190 --> 00:29:17,658 line:90%,end
<c.magenta>它的重要性是什么？</c>


496
00:29:18,091 --> 00:29:20,460 line:90%,end
<c.magenta>它并不利于资源管理</c>


497
00:29:20,527 --> 00:29:24,398 line:90%,end
<c.magenta>如果你有一个库用于特定硬件</c>


498
00:29:24,464 --> 00:29:27,968 line:90%,end
<c.magenta>你不应该关闭硬件</c>
<c.magenta>来响应dlclose</c>


499
00:29:28,035 --> 00:29:31,805 line:90%,end
<c.magenta>因为程序中的其它代码</c>
<c.magenta>可能会在后台打开硬件</c>


500
00:29:31,872 --> 00:29:33,407 line:90%,end
<c.magenta>因此你的硬件不会关闭</c>


501
00:29:33,473 --> 00:29:35,943 line:90%,end
<c.magenta>应该使用显式资源管理</c>


502
00:29:36,944 --> 00:29:39,213 line:90%,end
<c.magenta>我们的平台上还有很多特性</c>


503
00:29:39,279 --> 00:29:41,648 line:90%,end
<c.magenta>访止dylib被卸载</c>


504
00:29:41,715 --> 00:29:45,118 line:90%,end
<c.magenta>我想介绍几个例子</c>
<c.magenta>因为你们可能会这样做</c>


505
00:29:45,853 --> 00:29:47,754 line:90%,end
<c.magenta>你的dylib中可以</c>
<c.magenta>有Objective-C类</c>


506
00:29:47,821 --> 00:29:50,257 line:90%,end
<c.magenta>这将导致dylib不可卸载</c>


507
00:29:50,991 --> 00:29:54,228 line:90%,end
<c.magenta>你可以具有Swift类</c>
<c.magenta>这也会导致dylib不可卸载</c>


508
00:29:54,828 --> 00:29:58,232 line:10%
<c.magenta>你可以具有C底层线程</c>
<c.magenta>或C++ 线程本地变量</c>


509
00:29:58,298 --> 00:30:00,868 line:10%
<c.magenta>这些都会导致dylib不可卸载</c>


510
00:30:01,535 --> 00:30:06,573 line:10%
<c.magenta>因此在具有一些</c>
<c.magenta>现成Unix程序的macOS上</c>


511
00:30:06,640 --> 00:30:10,644 line:10%
<c.magenta>我们会保持这个特性</c>
<c.magenta>但是由于我们所有其它平台上的</c>


512
00:30:10,711 --> 00:30:12,946 line:10%
<c.magenta>几乎每个dylib都会这样做</c>


513
00:30:13,013 --> 00:30:17,084 line:10%
<c.magenta>因此并不能在这些平台上</c>
<c.magenta>有效地工作</c>


514
00:30:17,384 --> 00:30:20,988 line:10%
<c.magenta>因此我们可以将它视为</c>
<c.magenta>无操作指令</c>


515
00:30:21,054 --> 00:30:23,290 line:10%
<c.magenta>不会在任何平台上进行操作</c>


516
00:30:23,857 --> 00:30:28,695 line:10%
<c.magenta>如果这会导致问题</c>
<c.magenta>请告诉我们</c>


517
00:30:30,097 --> 00:30:33,600 line:10%
<c.magenta>最后我想讨论</c>
<c.magenta>dyld all image infos</c>


518
00:30:34,134 --> 00:30:37,337 line:90%,end
<c.magenta>这是进程中的</c>
<c.magenta>内在dylib的接口</c>


519
00:30:37,404 --> 00:30:39,306 line:90%,end
<c.magenta>它来自于最初的dyld 1</c>


520
00:30:40,641 --> 00:30:45,779 line:90%,end
<c.magenta>但是它只是内存中的一个结构</c>
<c.magenta>而不是API</c>


521
00:30:45,846 --> 00:30:48,148 line:90%,end
<c.magenta>当我们有5或10个dylib时</c>
<c.magenta>并没有问题</c>


522
00:30:48,415 --> 00:30:52,252 line:90%,end
<c.magenta>但是如果有300、400</c>
<c.magenta>500个dylib 其设计方式</c>


523
00:30:52,319 --> 00:30:54,821 line:90%,end
<c.magenta>将导致浪费大量内存</c>
<c.magenta>我们需要回收那些内存</c>


524
00:30:54,922 --> 00:30:57,624 line:90%,end
<c.magenta>我们需要高性能</c>
<c.magenta>而且节省内存</c>


525
00:30:58,192 --> 00:31:00,861 line:90%,end
<c.magenta>在未来的版本中</c>
<c.magenta>我们将会取消它</c>


526
00:31:01,161 --> 00:31:04,598 line:90%,end
<c.magenta>但 是会提供一个替代性API</c>


527
00:31:04,898 --> 00:31:08,502 line:90%,end
<c.magenta>因此 它很少被用到</c>
<c.magenta>如果你要使用它</c>


528
00:31:08,569 --> 00:31:10,370 line:90%,end
<c.magenta>我希望你知道为什么要使用它</c>


529
00:31:10,437 --> 00:31:13,941 line:90%,end
<c.magenta>如何使用它</c>
<c.magenta>确保我们设计的API适合你的用例</c>


530
00:31:14,208 --> 00:31:16,877 line:90%,end
<c.magenta>有很多功能已经不再适用</c>


531
00:31:16,944 --> 00:31:20,480 line:90%,end
<c.magenta>不符合你的预期</c>
<c.magenta>如果你不需要它们</c>


532
00:31:20,547 --> 00:31:23,016 line:90%,end
<c.magenta>可以忽略它们</c>
<c.magenta>我们希望获得这方面的信息</c>


533
00:31:23,550 --> 00:31:25,385 line:90%,end
<c.magenta>请让我们知道你将如何使用它</c>


534
00:31:25,853 --> 00:31:28,021 line:90%,end
<c.magenta>最后我们讨论最佳实践</c>


535
00:31:28,455 --> 00:31:33,527 line:90%,end
<c.magenta>首先应确保将bind at load</c>
<c.magenta>添加到LD FLAGS</c>


536
00:31:33,594 --> 00:31:35,395 line:90%,end
<c.magenta>应该仅在调试版本中这样做</c>


537
00:31:36,630 --> 00:31:40,033 line:90%,end
<c.magenta>应修复数据段中的</c>
<c.magenta>任何未对齐指针</c>


538
00:31:40,100 --> 00:31:42,836 line:90%,end
<c.magenta>然后还有这个警告信息</c>


539
00:31:42,903 --> 00:31:45,038 line:90%,end
<c.magenta>应该使用新Swift键径功能</c>


540
00:31:45,672 --> 00:31:47,975 line:90%,end
<c.magenta>消除所有警告错误</c>


541
00:31:48,041 --> 00:31:50,077 line:90%,end
<c.magenta>你也可以忽略</c>
<c.magenta>因为我们将会解决这个问题</c>


542
00:31:51,311 --> 00:31:54,281 line:90%,end
<c.magenta>当你调用dlclose时应该确保</c>


543
00:31:54,882 --> 00:31:56,283 line:90%,end
<c.magenta>不依赖于任何正运行的终止函数</c>


544
00:31:58,085 --> 00:32:03,924 line:90%,end
<c.magenta>我们想知道你们为何使用dlopen</c>
<c.magenta>dlsym、dladdr</c>


545
00:32:03,991 --> 00:32:07,694 line:90%,end
<c.magenta>和all image info结构</c>
<c.magenta>以确保我们的替代性API</c>


546
00:32:07,761 --> 00:32:09,863 line:90%,end
<c.magenta>能够满足你们的需求</c>


547
00:32:09,930 --> 00:32:12,499 line:90%,end
<c.magenta>如果它们是POSIX的一部分</c>
<c.magenta>将会被保留</c>


548
00:32:12,566 --> 00:32:14,768 line:90%,end
<c.magenta>这只会造成性能降低</c>
<c.magenta>对于all image infos</c>


549
00:32:14,835 --> 00:32:17,404 line:90%,end
<c.magenta>它将会被取消以节省内存</c>


550
00:32:18,572 --> 00:32:22,409 line:10%
<c.magenta>请使用DYLD USAGE标题</c>
<c.magenta>向我们报告漏洞</c>


551
00:32:22,476 --> 00:32:24,444 line:90%,end
<c.magenta>让我们能够</c>


552
00:32:24,511 --> 00:32:25,979 line:90%,end
<c.magenta>支持你们的所有用例</c>


553
00:32:26,313 --> 00:32:29,283 line:90%,end
<c.magenta>更多信息请访问此URL</c>


554
00:32:30,517 --> 00:32:34,488 line:90%,end
<c.magenta>去年我们举行了一个相关的演讲</c>
<c.magenta>名称为“缩短应用启动时间”</c>


555
00:32:34,555 --> 00:32:38,058 line:90%,end
<c.magenta>你可以观看这个演讲</c>


556
00:32:38,125 --> 00:32:40,861 line:90%,end
<c.magenta>复习传统动态链接的工作原理</c>


557
00:32:41,228 --> 00:32:43,997 line:90%,end
<c.magenta>这个演讲更详细</c>


558
00:32:44,064 --> 00:32:45,999 line:90%,end
<c.magenta>因为今天我们讲的都是新内容</c>


559
00:32:46,366 --> 00:32:50,037 line:90%,end
<c.magenta>谢谢大家参加本演讲</c>
<c.magenta>我希望你们度过一个很棒的WWDC</c>

